<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

-   [@airtable/blocks][1]
    -   [SDK][2]
    -   [globalConfig][3]
    -   [settingsButton][4]
    -   [Viewport][5]
-   [@airtable/blocks/models][6]
    -   [fieldTypes][7]
    -   [viewTypes][8]
    -   [recordColoring][9]
    -   [AbstractModel][10]
    -   [AbstractModelWithAsyncData][11]
    -   [Aggregator][12]
    -   [Base][13]
    -   [Session][14]
    -   [Cursor][15]
    -   [Field][16]
    -   [RecordQueryResult][17]
    -   [Record][18]
    -   [Table][19]
    -   [View][20]
    -   [ViewMetadataQueryResult][21]
    -   [Watchable][22]
-   [@airtable/blocks/ui][23]
    -   [initializeBlock][24]
    -   [CSS & external scripts][25]
    -   [Color utilities][26]
    -   [React hooks for working with Airtable data][27]
    -   [expandRecord][28]
    -   [expandRecordList][29]
    -   [expandRecordPickerAsync][30]
    -   [Button][31]
    -   [CellRenderer][32]
    -   [ChoiceToken][33]
    -   [CollaboratorToken][34]
    -   [ColorPalette][35]
    -   [ColorPaletteSynced][36]
    -   [ConfirmationDialog][37]
    -   [Dialog][38]
    -   [FieldPicker][39]
    -   [FieldPickerSynced][40]
    -   [Icon][41]
    -   [Input][42]
    -   [InputSynced][43]
    -   [Link][44]
    -   [Loader][45]
    -   [Popover][46]
    -   [ProgressBar][47]
    -   [RecordCard][48]
    -   [RecordCardList][49]
    -   [Select][50]
    -   [SelectSynced][51]
    -   [SelectButtons][52]
    -   [SelectButtonsSynced][53]
    -   [TablePicker][54]
    -   [TablePickerSynced][55]
    -   [Toggle][56]
    -   [ToggleSynced][57]
    -   [Tooltip][58]
    -   [ViewPicker][59]
    -   [ViewPickerSynced][60]
    -   [ViewportConstraint][61]

## @airtable/blocks

### SDK

#### [import {base} from '@airtable/blocks';][13]

An instance of [Base][13] representing the current Airtable base. If you're writing a React
Component, you might want to use the [useBase][62] hook rather than importing `base` directly.

#### [import {globalConfig} from '@airtable/blocks';][3]

[globalConfig][3] is a key-value store shared between every user of a particular installation of
your block. Use it for storing block configuration.

#### [import {session} from '@airtable/blocks';][14]

An instance of [Session][14], containing information about the current user's session. If you're
writing a React Component, you might want to use the [useSession][63] hook rather than importing
`session` directly.

#### [import {cursor} from '@airtable/blocks';][15]

An instance of [Cursor][15], containing information about the table & view that the user currently
has open in the main Airtable app, as well as which records they have selected.

#### [import {viewport} from '@airtable/blocks';][5]

Controls the block's viewport within Airtable. Use this to fullscreen the block and add size
constraints. See [Viewport][5].

#### [import {settingsButton} from '@airtable/blocks';][4]

Controls the block's settings button. See [settingsButton][4].

#### import {reload} from '@airtable/blocks';

Call this function to reload the block frame:

```js
import {reload} from '@airtable/blocks';
reload();
```

#### import {installationId} from '@airtable/blocks';

A unique ID for this block installation.

#### [import \* as models from '@airtable/blocks/models';][6]

Model classes, field types, view types, and utilities for working with record coloring and record
aggregation.

#### [import \* as UI from '@airtable/blocks/ui';][23]

React component library, hooks for integrating Airtable data with React components, and UI helpers.

### globalConfig

#### GlobalConfig

**Extends Watchable**

A key-value store for persisting configuration options for a block installation.

The contents will be synced in real-time to all logged-in users of the installation. Contents will
not be updated in real-time when the installation is running in a publicly shared base.

Any key can be watched to know when the value of the key changes.

You should not need to construct this object yourself.

##### Examples

```javascript
import {globalConfig} from '@airtable/blocks';
```

##### checkPermissionsForSet

Checks whether the current user has permission to set the given global config key.

Accepts partial input, in the same format as [setAsync][64]. The more information provided, the more
accurate the permissions check will be.

###### Parameters

-   `key` **([string][65] \| [Array][66]&lt;[string][65]>)?** A string for the top-level key, or an
    array of strings describing the path to set.
-   `value` **([GlobalConfigValue][67] | void)?** The value to set at the specified path. Use
    `undefined` to delete the value at the given path.

###### Examples

```javascript
// Check if user can update a specific key and value.
const setCheckResult = globalConfig.checkPermissionsForSet('favoriteColor', 'purple');
if (!setCheckResult.hasPermission) {
    alert(setCheckResult.reasonDisplayString);
}

// Check if user can update a specific key, when you don't know the value yet.
const setKeyCheckResult = globalConfig.checkPermissionsForSet('favoriteColor');

// Check if user could set globalConfig values, without knowing the specific key/value yet
const setUnknownKeyCheckResult = globalConfig.checkPermissionsForSet();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can set the specified key, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

##### checkPermissionsForSetPaths

Checks whether the current user has permission to perform the specified updates to global config.

Accepts partial input, in the same format as [setPathsAsync][68]. The more information provided, the
more accurate the permissions check will be.

###### Parameters

-   `updates` **($ReadOnlyArray&lt;{path: ($ReadOnlyArray&lt;([string][65] | void)> | void)?, value:
    ([GlobalConfigValue][67] | void)?}> | void)?**

###### Examples

```javascript
// Check if user can update a specific keys and values.
const setPathsCheckResult = globalConfig.checkPermissionsForSet([
    {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
    {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
]);
if (!setPathsCheckResult.hasPermission) {
    alert(setPathsCheckResult.reasonDisplayString);
}

// Check if user could potentially set globalConfig values.
// Equivalent to globalConfig.checkPermissionsForSet()
const setUnknownPathsCheckResult = globalConfig.checkPermissionsForSetPaths();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can set the specified key, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

##### get

Get the value at a path. Throws an error if the path is invalid.

###### Parameters

-   `key` **([string][65] \| [Array][66]&lt;[string][65]>)** A string for the top-level key, or an
    array of strings describing the path to the value.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

const topLevelValue = globalConfig.get('topLevelKey');
const nestedValue = globalConfig.get(['topLevelKey', 'nested', 'deeply']);
```

Returns **([GlobalConfigValue][67] | void)** The value at the provided path, or `undefined` if no
value exists at that path.

##### hasPermissionToSet

An alias for `globalConfig.checkPermissionsForSet(key, value).hasPermission`.

Checks whether the current user has permission to set the given global config key.

Accepts partial input, in the same format as [setAsync][64]. The more information provided, the more
accurate the permissions check will be.

###### Parameters

-   `key` **([string][65] \| [Array][66]&lt;[string][65]>)?** A string for the top-level key, or an
    array of strings describing the path to set.
-   `value` **([GlobalConfigValue][67] | void)?** The value to set at the specified path. Use
    `undefined` to delete the value at the given path.

###### Examples

```javascript
// Check if user can update a specific key and value.
const canSetFavoriteColorToPurple = globalConfig.hasPermissionToSet('favoriteColor', 'purple');
if (!canSetFavoriteColorToPurple) {
    alert('Not allowed!');
}

// Check if user can update a specific key, when you don't know the value yet.
const canSetFavoriteColor = globalConfig.hasPermissionToSet('favoriteColor');

// Check if user could set globalConfig values, without knowing the specific key/value yet
const canSetGlobalConfig = globalConfig.hasPermissionToSet();
```

Returns **[boolean][69]** boolean Whether or not the user can set the specified key.

##### hasPermissionToSetPaths

An alias for `globalConfig.checkPermissionsForSetPaths(updates).hasPermission`.

Checks whether the current user has permission to perform the specified updates to global config.

Accepts partial input, in the same format as [setPathsAsync][68]. The more information provided, the
more accurate the permissions check will be.

###### Parameters

-   `updates` **($ReadOnlyArray&lt;{path: ($ReadOnlyArray&lt;([string][65] | void)> | void)?, value:
    ([GlobalConfigValue][67] | void)?}> | void)?**

###### Examples

```javascript
// Check if user can update a specific keys and values.
const canSetPaths = globalConfig.hasPermissionToSetPaths([
    {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
    {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
]);
if (!canSetPaths) {
    alert('not allowed!');
}

// Check if user could potentially set globalConfig values.
// Equivalent to globalConfig.hasPermissionToSet()
const canSetAnyPaths = globalConfig.hasPermissionToSetPaths();
```

Returns **[boolean][69]** boolean Whether or not the user has permission to apply the specified
updates to globalConfig.

##### setAsync

Sets a value at a path. Throws an error if the path or value is invalid.

This action is asynchronous: `await` the returned promise if you wish to wait for the update to be
persisted to Airtable servers. Updates are applied optimistically locally, so your change will be
reflected in [GlobalConfig][3] before the promise resolves.

###### Parameters

-   `key` **([string][65] \| [Array][66]&lt;[string][65]>)** A string for the top-level key, or an
    array of strings describing the path to set.
-   `value` **([GlobalConfigValue][67] | void)** The value to set at the specified path. Use
    `undefined` to delete the value at the given path.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

function updateFavoriteColorIfPossible(color) {
    if (globalConfig.hasPermissionToSetPaths('favoriteColor', color)) {
        globalConfig.setPathsAsync('favoriteColor', color);
    }
    // The update is now applied within your block (eg will be reflected in
    // globalConfig) but are still being saved to Airtable servers (eg.
    // may not be updated for other users yet)
}

async function updateFavoriteColorIfPossibleAsync(color) {
    if (globalConfig.hasPermissionToSet('favoriteColor', color)) {
        await globalConfig.setAsync('favoriteColor', color);
    }
    // globalConfig updates have been saved to Airtable servers.
    alert('favoriteColor has been updated');
}
```

Returns **[Promise][70]&lt;void>** A promise that will resolve once the update is persisted to
Airtable.

##### setPathsAsync

Sets multiple values. Throws if any path or value is invalid.

This action is asynchronous: `await` the returned promise if you wish to wait for the updates to be
persisted to Airtable servers. Updates are applied optimistically locally, so your changes will be
reflected in [GlobalConfig][3] before the promise resolves.

###### Parameters

-   `updates` **[Array][66]&lt;{path: [Array][66]&lt;[string][65]>, value:
    [GlobalConfigValue][67]}>** The paths and values to set.

###### Examples

```javascript
import {globalConfig} from '@airtable/blocks';

const updates = [
    {path: ['topLevelKey1', 'nestedKey1'], value: 'foo'},
    {path: ['topLevelKey2', 'nestedKey2'], value: 'bar'},
];

function applyUpdatesIfPossible() {
    if (globalConfig.hasPermissionToSetPaths(updates)) {
        globalConfig.setPathsAsync(updates);
    }
    // The updates are now applied within your block (eg will be reflected in
    // globalConfig) but are still being saved to Airtable servers (eg. they
    // may not be updated for other users yet)
}

async function applyUpdatesIfPossibleAsync() {
    if (globalConfig.hasPermissionToSetPaths(updates)) {
        await globalConfig.setPathsAsync(updates);
    }
    // globalConfig updates have been saved to Airtable servers.
    alert('globalConfig has been updated');
}
```

Returns **[Promise][70]&lt;void>** A promise that will resolve once the update is persisted to
Airtable.

##### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

###### Parameters

-   `keys` **(WatchableGlobalConfigKey | [Array][66]&lt;WatchableGlobalConfigKey>)** the keys to
    unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableGlobalConfigKey>** the array of keys that were unwatched

##### watch

Get notified of changes to global config.

You can watch any top-level key in global config. Use '\*' to watch every change.

Every call to `.watch` should have a matching call to `.unwatch`.

###### Parameters

-   `keys` **(WatchableGlobalConfigKey | [Array][66]&lt;WatchableGlobalConfigKey>)** the keys to
    watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableGlobalConfigKey>** the array of keys that were watched

#### GlobalConfigKey

Type: ([string][65] \| [Array][66]&lt;[string][65]>)

#### GlobalConfigValue

Type: (null | [boolean][69] \| [number][73] \| [string][65] \|
[Array][66]&lt;[GlobalConfigValue][67]> | [Object][72]&lt;[string][65], [GlobalConfigValue][67]>)

### settingsButton

**Extends Watchable**

Interface to the settings button that lives outside the block's viewport.

The [useSettingsButton][74] hook is the recommend way to watch the settings button, but you can also
use it directly as per below example.

Watch `click` to handle click events on the button.

#### Examples

```javascript
import {settingsButton} from '@airtable/blocks';
// Button is not visible by default
settingsButton.show();
settingsButton.watch('click', () => {
    alert('Clicked!');
});
```

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableSettingsButtonKey | [Array][66]&lt;WatchableSettingsButtonKey>)** the keys to
    unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableSettingsButtonKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the settings button.

Watchable keys are:

-   `'isVisible'`
-   `'click'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableSettingsButtonKey | [Array][66]&lt;WatchableSettingsButtonKey>)** the keys to
    watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableSettingsButtonKey>** the array of keys that were watched

#### hide

Hide the settings button.

Note: A count of calls to `show()` and `hide()` is maintained internally. The button will stay
visible if there are more calls to `show()` than `hide()`.

#### isVisible

Whether the settings button is being shown. Can be watched.

Type: [boolean][69]

Returns **[boolean][69]**

#### show

Show the settings button.

### Viewport

**Extends Watchable**

Information about the current viewport

#### Examples

```javascript
import {viewport} from '@airtable/blocks';
```

#### addMaxFullscreenSize

Add a maximum fullscreen size constraint. Use \`.maxFullscreenSize`` to get the aggregate of all
added constraints.

##### Parameters

-   `sizeConstraint` **{width: ([number][73] | null), height: ([number][73] | null)}** The width and
    height constraints to add. Both `width` and `height` are optional - if either is set to null,
    that means there is no max size in that dimension.

Returns **[Function][71]** A function that can be called to remove the fullscreen size constraint
that was added.

#### addMinSize

Add a minimum frame size constraint. Use \`.minSize`` to get the aggregate of all added constraints.

Upon adding a constraint, if the block is focused and the frame is smaller than the minimum size,
the block will enter fullscreen mode.

##### Parameters

-   `sizeConstraint` **{width: ([number][73] | null), height: ([number][73] | null)}** The width and
    height constraints to add. Both `width` and `height` are optional - if either is set to null,
    that means there is no min size in that dimension.

Returns **[Function][71]** A function that can be called to remove the size constraint that was
added.

#### enterFullscreenIfPossible

Request to enter fullscreen mode.

May fail if another block is fullscreen or this block doesn't have permission to fullscreen itself.
Watch `isFullscreen` to know if the request succeeded.

#### exitFullscreen

Request to exit fullscreen mode

#### isFullscreen

Boolean to denote whether the block is currently fullscreen.

Can be watched.

Type: [boolean][69]

Returns **[boolean][69]** `true` if the block is fullscreen, `false` otherwise.

#### isSmallerThanMinSize

Boolean to denote whether the block frame is smaller than the `minSize`.

Type: [boolean][69]

Returns **[boolean][69]** `true` if the block frame is smaller than `minSize`, `false` otherwise.

#### maxFullscreenSize

The maximum dimensions of the block when it is in fullscreen mode. Returns the smallest set of
dimensions added with [addMaxFullscreenSize][75].

If `width` or `height` is null, it means there is no max size constraint on that dimension. If
`maxFullscreenSize` would be smaller than [minSize][76], it is constrained to be at least `minSize`.

Type: ViewportSizeConstraint

Returns **{width: ([number][73] | null), height: ([number][73] | null)}** maxSize

#### minSize

The minimum dimensions of the block - if the viewport gets smaller than this size, an overlay will
be shown asking the user to resize the block to be bigger.

Type: ViewportSizeConstraint

Returns **{width: ([number][73] | null), height: ([number][73] | null)}** The largest set of
dimensions added with addMinSize. If `width` or `height` is null, it means there is no minSize
constraint on that dimension.

#### size

The current size of the block frame.

Can be watched.

Type: {width: [number][73], height: [number][73]}

Returns **{width: [number][73], height: [number][73]}** The current size of the block frame.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableViewportKey | [Array][66]&lt;WatchableViewportKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableViewportKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the viewport.

Watchable keys are:

-   `'isFullscreen'`
-   `'size'`
-   `'minSize'`
-   `'maxFullscreenSize'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableViewportKey | [Array][66]&lt;WatchableViewportKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableViewportKey>** the array of keys that were watched

## @airtable/blocks/models

### fieldTypes

An enum of Airtable's field types

#### Examples

```javascript
import {fieldTypes} from '@airtable/blocks/models';
const numberFields = myTable.fields.filter(field => field.type === fieldTypes.NUMBER);
```

#### fieldTypes.AUTO_NUMBER

Automatically incremented unique counter for each record.

##### Cell value format

```js
number;
```

##### Options

None

#### fieldTypes.BARCODE

Use the Airtable iOS or Android app to scan barcodes.

##### Cell value format

```js
{
    // the text value of the barcode
    text: string,
    // the type of barcode
    type?: string,
}
```

##### Options

None

#### fieldTypes.CHECKBOX

A checkbox.

##### Cell value format

```js
boolean;
```

This field is "true" when checked and otherwise empty.

##### Options

```js
{
    // an [Icon](#icon) name
    icon: string,
    // the color of the check box
    color: Color,
}
```

#### fieldTypes.COUNT

Count the number of linked records.

##### Cell value format

```js
number;
```

##### Options

```js
{
   // is the field currently valid (false if e.g. the linked record field is switched to a different type)
   isValid: boolean,
   // the linked record field in this table that we're counting
   recordLinkFieldId: FieldId,
}
```

#### fieldTypes.CREATED_TIME

The time the record was created in UTC.

##### Cell value format

```js
string;
```

An [ISO 8601][77] formatted date time.

##### Options

```js
{
    result: {
        type: 'date' | 'dateTime',
        options: DateOrDateTimeFieldOptions,
    },
}
```

See [fieldTypes.DATE][78] and [fieldTypes.DATE_TIME][79] for `result` options.

#### fieldTypes.CURRENCY

An amount of a currency.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
    symbol: string,
}
```

#### fieldTypes.DATE

A date.

##### Cell value format

```js
string;
```

An [ISO 8601][77] formatted date.

##### Options

```js
{
    dateFormat: {
        name: 'local' | 'friendly' | 'us' | 'european' | 'iso',
        // a date format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    }
}
```

#### fieldTypes.DATE_TIME

A date & time.

##### Cell value format

```js
string;
```

An [ISO 8601][77] formatted date time.

##### Options

```js
{
    dateFormat: {
        name: 'local' | 'friendly' | 'us' | 'european' | 'iso',
        // a date format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    },
    timeFormat: {
        name: '12hour' | '24hour',
        // a time format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
        format: string,
    },
    timeZone: 'utc' | 'client',
}
```

#### fieldTypes.DURATION

A duration of time in seconds.

##### Cell value format

```js
number;
```

##### Options

```js
{
    // a time format string as documented here: https://momentjs.com/docs/#/parsing/string-format/
    durationFormat: string,
}
```

#### fieldTypes.EMAIL

A valid email address (e.g. andrew@example.com).

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.FORMULA

Compute a value in each record based on other fields in the same record.

##### Cell value format

```js
any;
```

Check `options.result` to know the resulting field type.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the other fields in the record that are used in the formula
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the resulting field type and options returned by the formula
    result: {
        // the field type of the formula result
        type: string,
        // that types options
        options?: any,
    },
}
```

#### fieldTypes.LAST_MODIFIED_TIME

Shows the date and time that a record was most recently modified in any editable field or just in
specific editable fields.

##### Cell value format

```js
string;
```

An [ISO 8601][77] formatted date time.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the fields to check the last modified time of
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the cell value result type
    result: {
        type: 'date' | 'dateTime',
        options: DateOrDateTimeFieldOptions,
    },
}
```

See [fieldTypes.DATE][78] and [fieldTypes.DATE_TIME][79] for `result` options.

#### fieldTypes.LOOKUP

Lookup a field on linked records.

##### Cell value format

UNSTABLE

##### Options

UNSTABLE

#### fieldTypes.MULTILINE_TEXT

A long text field that can span multiple lines.

###### Cell value format

```js
string;
```

Multiple lines of text, which may contain "mention tokens", e.g.
`<airtable:mention id="menE1i9oBaGX3DseR">@Alex</airtable:mention>`

###### Options

None

#### fieldTypes.MULTIPLE_ATTACHMENTS

Attachments allow you to add images, documents, or other files which can then be viewed or
downloaded.

##### Cell value format

```js
Array<{
    // unique attachment id
    id: string,
    // url, e.g. "https://dl.airtable.com/foo.jpg"
    url: string,
    // filename, e.g. "foo.jpg"
    filename: string,
    // file size, in bytes
    size?: number,
    // content type, e.g. "image/jpeg"
    type?: string,
    // thumbnails if available
    thumbnails: {
        small?: {
            url: string,
            width?: number,
            height?: number,
        },
        large?: {
            url: string,
            width?: number,
            height?: number,
        },
        full?: {
            url: string,
            width?: number,
            height?: number,
        },
    },
}>
```

##### Options

None

#### fieldTypes.MULTIPLE_COLLABORATORS

A collaborator field lets you add collaborators to your records. Collaborators can optionally be
notified when they're added.

##### Cell value format

```js
Array<{
    id: string,
    email: string,
    name?: string,
    profilePicUrl?: string,
}>
```

Array of selected choices.

##### Options

```js
{
    choices: Array<{
        id: string,
        email: string,
        name?: string,
        profilePicUrl?: string,
    }>,
}
```

#### fieldTypes.MULTIPLE_RECORD_LINKS

Link to another record.

##### Cell value format

```js
Array<{
    id: RecordId,
    name: string,
}>
```

Array of selected record IDs and their primary cell values from the linked table.

##### Options

```js
{
    // The ID of the table this field links to
    linkedTableId: TableId,
    // The ID of the field in the linked table that links back to this one
    inverseLinkFieldId?: FieldId,
    // The ID of the view in the linked table to use when showing a list of records to select from
    viewIdForRecordSelection?: ViewId,
}
```

#### fieldTypes.MULTIPLE_SELECTS

Multiple select allows you to select one or more predefined options from a dropdown

##### Cell value format

```js
Array<{
    id: string,
    name: string,
    color?: Color,
}>
```

Array of selected choices.

##### Options

```js
{
    choices: Array<{
        id: string,
        name: string,
        color?: Color,
    }>,
}
```

#### fieldTypes.NUMBER

A number.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
}
```

#### fieldTypes.PERCENT

A percentage - 0 is 0%, 1 is 100%.

##### Cell value format

```js
number;
```

##### Options

```js
{
    precision: number,
}
```

#### fieldTypes.PHONE_NUMBER

A telephone number (e.g. (415) 555-9876).

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.RATING

A rating (e.g. stars out of 5)

##### Cell value format

```js
number;
```

##### Options

```js
{
    // the [Icon](#icon) name used to display the rating
    icon: string,
    // the maximum value for the rating
    max: number,
    // the color of selected icons
    color: Color,
}
```

#### fieldTypes.ROLLUP

A rollup allows you to summarize data from records that are linked to this table.

##### Cell value format

```js
any;
```

Check `options.result` to know the resulting field type.

##### Options

```js
{
    // false if the formula contains an error
    isValid: boolean,
    // the linked record field in this table that this field is summarizing.
    recordLinkFieldId: FieldId,
    // the field id in the linked table that this field is summarizing.
    fieldIdInLinkedTable: FieldId,
    // the other fields in the record that are used in the formula
    fieldIdsReferencedByFormulaText: Array<FieldId>,
    // the resulting field type and options returned by the formula
    result: {
        // the field type of the formula result
        type: string,
        // that types options
        options?: any,
    },
}
```

#### fieldTypes.SINGLE_COLLABORATOR

A collaborator field lets you add collaborators to your records. Collaborators can optionally be
notified when they're added.

##### Cell value format

```js
{
    id: string,
    email: string,
    name?: string,
    profilePicUrl?: string,
}
```

The currently selected choice.

##### Options

```js
{
    choices: Array<{
        id: string,
        email: string,
        name?: string,
        profilePicUrl?: string,
    }>,
}
```

#### fieldTypes.SINGLE_LINE_TEXT

A single line of text.

##### Cell value format

```js
string;
```

##### Options

None

#### fieldTypes.SINGLE_SELECT

Single select allows you to select a single option from predefined options in a dropdown.

##### Cell value format

```js
{
    id: string,
    name: string,
    color?: Color
}
```

The currently selected choice.

##### Options

```js
{
    choices: Array<{
        id: string,
        name: string,
        color?: Color,
    }>,
}
```

#### fieldTypes.URL

A valid URL (e.g. airtable.com or [https://airtable.com/universe][80]).

###### Cell value format

```js
string;
```

###### Options

None

### viewTypes

An enum of Airtable's view types

#### Examples

```javascript
import {viewTypes} from '@airtable/blocks/models';
const gridViews = myTable.views.filter(view => view.type === viewTypes.GRID);
```

#### viewTypes.CALENDAR

#### viewTypes.FORM

#### viewTypes.GALLERY

#### viewTypes.GRID

#### viewTypes.KANBAN

### recordColoring

Record coloring configuration used with [RecordQueryResult][17]s.

#### recordColoring.modes

Record coloring config creators.

##### Examples

```javascript
import {recordColoring} from '@airtable/blocks/models';

// no record coloring:
const recordColorMode = recordColoring.modes.none();
// color by select field:
const recordColorMode = recordColoring.modes.bySelectField(someSelectField);
// color from view:
const recordColorMode = recordColoring.modes.byView(someView);

// with a query result:
const queryResult = table.selectRecords({recordColorMode});
```

#### recordColoring.modes.bySelectField

##### Parameters

-   `selectField` **[Field][81]**

Returns **{type: recordColoring.ModeTypes.BY_SELECT_FIELD, selectField: [Field][81]}**

#### recordColoring.modes.byView

##### Parameters

-   `view` **[View][82]**

Returns **{type: recordColoring.ModeTypes.BY_VIEW, view: [View][82]}**

#### recordColoring.modes.none

Returns **{type: recordColoring.ModeTypes.NONE}**

#### recordColoring.ModeTypes

An enum of the different types of [recordColoring.modes][83]

#### recordColoring.ModeTypes.BY_SELECT_FIELD

#### recordColoring.ModeTypes.BY_VIEW

#### recordColoring.ModeTypes.NONE

### AbstractModel

**Extends Watchable**

Abstract superclass for all models. You won't use this class directly.

#### id

Type: [string][65]

Returns **[string][65]** The ID for this model.

#### isDeleted

A boolean denoting whether the model has been deleted.

In general, it's best to avoid keeping a reference to an object past the current event loop, since
it may be deleted and trying to access any data of a deleted object (other than its ID) will throw.
But if you keep a reference, you can use `isDeleted` to check that it's safe to access the model's
data.

Type: [boolean][69]

Returns **[boolean][69]** `true` if the model has been deleted, and `false` otherwise.

#### toString

Returns **[string][65]** A string representation of the model for use in debugging.

### AbstractModelWithAsyncData

**Extends AbstractModel**

Abstract superclass for all block SDK models that need to fetch async data.

#### Parameters

-   `baseData` **BaseData**
-   `modelId` **[string][65]**

#### isDataLoaded

Type: [boolean][69]

Returns **[boolean][69]**

#### loadDataAsync

Will cause all the async data to be fetched and retained. Every call to `loadDataAsync` should have
a matching call to `unloadData`.

Returns a Promise that will resolve once the data is loaded.

#### unloadData

#### unwatch

Unwatching a key that needs to load data asynchronously will automatically cause the data to be
released. Once the data is available, the callback will be called.

##### Parameters

-   `keys` **(WatchableKey | [Array][66]&lt;WatchableKey>)**
-   `callback` **[Function][71]**
-   `context` **[Object][72]??**

Returns **[Array][66]&lt;WatchableKey>**

#### watch

Watching a key that needs to load data asynchronously will automatically cause the data to be
fetched. Once the data is available, the callback will be called.

##### Parameters

-   `keys` **(WatchableKey | [Array][66]&lt;WatchableKey>)**
-   `callback` **[Function][71]**
-   `context` **[Object][72]??**

Returns **[Array][66]&lt;WatchableKey>**

### Aggregator

Aggregators can be used to compute aggregates for cell values.

Type: {key: [string][65], displayName: [string][65], shortDisplayName: [string][65], aggregate:
function (records: [Array][66]&lt;[Record][84]>, field: [Field][81]): any, aggregateToString:
function (records: [Array][66]&lt;[Record][84]>, field: [Field][81]): [string][65]}

#### Properties

-   `key` **[string][65]**
-   `displayName` **[string][65]**
-   `shortDisplayName` **[string][65]**
-   `aggregate` **function (records: [Array][66]&lt;[Record][84]>, field: [Field][81]): any**
-   `aggregateToString` **function (records: [Array][66]&lt;[Record][84]>, field: [Field][81]):
    [string][65]**

#### Examples

```javascript
// To get a list of aggregators supported for a specific field:
const fieldAggregators = myField.availableAggregators;

// To compute the total attachment size of an attachment field:
import {aggregators} from '@airtable/blocks/models';
const aggregator = aggregators.totalAttachmentSize;
const value = aggregator.aggregate(myRecords, myAttachmentField);
const valueAsString = aggregate.aggregateToString(myRecords, myAttachmentField);
```

### Base

**Extends AbstractModel**

Model class representing a base.

#### Examples

```javascript
import {base} from '@airtable/blocks';

console.log('The name of your base is', base.name);
```

#### activeCollaborators

Type: [Array][66]&lt;CollaboratorData>

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(base.activeCollaborators[0].email);
```

Returns **[Array][66]&lt;CollaboratorData>** The users who have access to this base.

#### getCollaboratorById

##### Parameters

-   `collaboratorId` **UserId** The ID of the user.

Returns **CollaboratorData** The user matching the given ID. Throws if that user does not exist or
does not have access to this base. Use [getCollaboratorByIdIfExists][85] instead if you are unsure
whether a collaborator with the given ID exists and has access to this base.

#### getCollaboratorByIdIfExists

##### Parameters

-   `collaboratorId` **UserId** The ID of the user.

Returns **(CollaboratorData | null)** The user matching the given ID, or `null` if that user does
not exist or does not have access to this base.

#### getTableById

##### Parameters

-   `tableId` **[string][65]** The ID of the table.

Returns **[Table][86]** The table matching the given ID. Throws if that table does not exist in this
base. Use [getTableByIdIfExists][87] instead if you are unsure whether a table exists with the given
ID.

#### getTableByIdIfExists

##### Parameters

-   `tableId` **[string][65]** The ID of the table.

Returns **([Table][86] | null)** The table matching the given ID, or `null` if that table does not
exist in this base.

#### getTableByName

##### Parameters

-   `tableName` **[string][65]** The name of the table you're looking for.

Returns **[Table][86]** The table matching the given name. Throws if no table exists with that name
in this base. Use [getTableByNameIfExists][88] instead if you are unsure whether a table exists with
the given name.

#### getTableByNameIfExists

##### Parameters

-   `tableName` **[string][65]** The name of the table you're looking for.

Returns **([Table][86] | null)** The table matching the given name, or `null` if no table exists
with that name in this base.

#### id

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(base.id);
// => 'appxxxxxxxxxxxxxx'
```

Returns **[string][65]** This base's ID.

#### name

Type: [string][65]

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log('The name of your base is', base.name);
```

Returns **[string][65]** The name of the base.

#### tables

Type: [Array][66]&lt;[Table][86]>

##### Examples

```javascript
import {base} from '@airtable/blocks';
console.log(`You have ${base.tables.length} tables`);
```

Returns **[Array][66]&lt;[Table][86]>** The tables in this base. Can be watched to know when tables
are created, deleted, or reordered in the base.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableBaseKey | [Array][66]&lt;WatchableBaseKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableBaseKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the base.

Watchable keys are:

-   `'name'`
-   `'tables'`
-   `'collaborators'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableBaseKey | [Array][66]&lt;WatchableBaseKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableBaseKey>** the array of keys that were watched

### Session

**Extends AbstractModel**

Model class representing the current user's session.

#### Examples

```javascript
import {session} from '@airtable/blocks';

if (session.currentUser !== null) {
    console.log("The current user's name is", session.currentUser.name);
} else {
    console.log('This block is being viewed in a public share');
}
```

#### currentUser

Type: (CollaboratorData | null)

##### Examples

```javascript
import {session} from '@airtable/blocks';
if (session.currentUser) {
    console.log(session.currentUser.id);
    console.log(session.currentUser.email);
    console.log(session.currentUser.name);
}
```

Returns **(CollaboratorData | null)** The current user, or `null` if the block is running in a
publicly shared base.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableSessionKey | [Array][66]&lt;WatchableSessionKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableSessionKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the session.

Watchable keys are:

-   `'permissionLevel'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableSessionKey | [Array][66]&lt;WatchableSessionKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableSessionKey>** the array of keys that were watched

### Cursor

**Extends AbstractModelWithAsyncData**

Contains information about the state of the user's current interactions in Airtable

#### Examples

```javascript
import {cursor} from '@airtable/blocks';
```

#### activeTableId

The currently active table ID.

Can be watched.

Type: (TableId | null)

Returns **(TableId | null)** The currently active table ID. Can return null when the active table
has changed and is not yet loaded.

#### activeViewId

The currently active view ID. This will always be a view belonging to `activeTableId`

Can be watched.

Type: (ViewId | null)

Returns **(ViewId | null)** The currently active view ID. Can return null when the active view has
changed and is not yet loaded.

#### isRecordSelected

Checks whether a given record is selected.

##### Parameters

-   `recordOrRecordId` **([Record][84] \| [string][65])** The record or record ID to check for.

Returns **[boolean][69]** `true` if the given record is selected, `false` otherwise.

#### selectedRecordIds

The record IDs of all currently selected records, or an empty array if no records are selected.

Can be watched.

Type: [Array][66]&lt;RecordId>

Returns **[Array][66]&lt;RecordId>** The record IDs of all currently selected records, or an empty
array if no records are selected.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableCursorKey | [Array][66]&lt;WatchableCursorKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableCursorKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the cursor.

Watchable keys are:

-   `'selectedRecordIds'`
-   `'activeTableId'`
-   `'activeViewId'`
-   `'isDataLoaded'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableCursorKey | [Array][66]&lt;WatchableCursorKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableCursorKey>** the array of keys that were watched

### Field

**Extends AbstractModel**

Model class representing a field in a table.

#### Examples

```javascript
import {base} from '@airtable/blocks';

const table = base.getTableByName('Table 1');
const field = table.getFieldByName('Name');
console.log('The type of this field is', field.type);
```

#### availableAggregators

Type: [Array][66]&lt;[Aggregator][89]>

##### Examples

```javascript
const fieldAggregators = myField.availableAggregators;
```

Returns **[Array][66]&lt;[Aggregator][89]>** A list of available aggregators given this field's
configuration.

#### convertStringToCellValue

Given a string, will attempt to parse it and return a valid cell value for the field's current
config.

##### Parameters

-   `string` **[string][65]** The string to parse.

##### Examples

```javascript
const inputString = '42';
const cellValue = myNumberField.convertStringToCellValue(inputString);
console.log(cellValue === 42);
// => true
```

Returns **any** The parsed cell value, or `null` if unable to parse the given string.

#### id

##### Examples

```javascript
console.log(myField.id);
// => 'fldxxxxxxxxxxxxxx'
```

Returns **[string][65]** This field's ID.

#### isAggregatorAvailable

##### Parameters

-   `aggregator` **([Aggregator][89] \| [string][65])** The aggregator object or aggregator key.

##### Examples

```javascript
import {aggregators} from '@airtable/blocks/models';
const aggregator = aggregators.totalAttachmentSize;

// Using an aggregator object
console.log(myAttachmentField.isAggregatorAvailable(aggregator));
// => true

// Using an aggregator key
console.log(mySingleLineTextField.isAggregatorAvailable('totalAttachmentSize'));
// => false
```

Returns **[boolean][69]** `true` if the given aggregator is available for this field, `false`
otherwise.

#### isComputed

Type: [boolean][69]

##### Examples

```javascript
console.log(mySingleLineTextField.isComputed);
// => false
console.log(myAutoNumberField.isComputed);
// => true
```

Returns **[boolean][69]** `true` if this field is computed, `false` otherwise. A field is "computed"
if it's value is not set by user input (e.g. autoNumber, formula, etc.). Can be watched.

#### isDeleted

True if this field has been deleted.

In general, it's best to avoid keeping a reference to a field past the current event loop, since it
may be deleted and trying to access any data of a deleted field (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the field's
data.

##### Examples

```javascript
if (!myField.isDeleted) {
    // Do things with myField
}
```

Returns **[boolean][69]** `true` if the field has been deleted, `false` otherwise.

#### isPrimaryField

Type: [boolean][69]

Returns **[boolean][69]** `true` if this field is its parent table's primary field, `false`
otherwise. Should never change because the primary field of a table cannot change.

#### name

Type: [string][65]

##### Examples

```javascript
console.log(myField.name);
// => 'Name'
```

Returns **[string][65]** The name of the field. Can be watched.

#### options

Type: ({} | null)

##### Examples

```javascript
import {fieldTypes} from '@airtable/blocks/models';

if (myField.type === fieldTypes.CURRENCY) {
    console.log(myField.options.symbol);
    // => '$'
}
```

Returns **({} | null)** The configuration options of the field. The structure of the field's options
depend on the field's type. Can be watched.

#### type

Type: [string][65]

##### Examples

```javascript
console.log(myField.type);
// => 'singleLineText'
```

Returns **[string][65]** The type of the field. Can be watched.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableFieldKey | [Array][66]&lt;WatchableFieldKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableFieldKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the field.

Watchable keys are:

-   `'name'`
-   `'type'`
-   `'options'`
-   `'isComputed'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableFieldKey | [Array][66]&lt;WatchableFieldKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableFieldKey>** the array of keys that were watched

### RecordQueryResult

#### RecordQueryResult

**Extends AbstractModelWithAsyncData**

A RecordQueryResult represents a set of records. It's a little bit like a one-off View in Airtable:
it contains a bunch of records, filtered to a useful subset of the records in the table. Those
records can be sorted according to your specification, and they can be colored by a select field or
using the color from a view. Just like a view, you can either have all the fields in a table
available, or you can just ask for the fields that are relevant to you. There are two types of
QueryResult:

-   [TableOrViewQueryResult][90] is the most common, and is a query result filtered to all the
    records in a specific [Table][19] or [View][20]. You can get one of these with
    `table.selectRecords()` or `view.selectRecords()`.
-   [LinkedRecordsQueryResult][91] is a query result of all the records in a particular [linked
    record cell][92]. You can get one of these with `record.selectLinkedRecordsFromCell(someField)`.

Once you've got a query result, you need to load it before you can start working with it. When
you're finished, unload it:

```js
async function fetchRecordsAndDoSomethingAsync(myTable) {
    // query for all the records in "myTable"
    const queryResult = myTable.selectRecords();

    // load the data in the query result:
    await queryResult.loadDataAsync();

    // work with the data in the query result
    doSomething(queryResult);

    // when you're done, unload the data:
    queryResult.unloadData();
}
```

If you're using a query result in a React component, you don't need to worry about this. Just use
[useRecords][93], [useRecordIds][94], [useRecordById][95] or [useLoadable][96], which will handle
all that for you.

Whilst loaded, a query result will automatically keep up to date with what's in Airtable: records
will get added or removed, the order will change, cell values will be updated, etc. Again, if you're
writing a React component then our hooks will look after that for you. If not, you can get notified
of these changes with `.watch()`.

When calling a `.select*` method, you can pass in a number of options:

##### sorts

Pass an array of sorts to control the order of records within the query result. The first sort in
the array has the highest priority. If you don't specify sorts, the query result will use the
inherent order of the source model: the same order you'd see in the main UI for views and linked
record fields, and an arbitrary (but stable) order for tables.

```js
view.selectRecords({
    sorts: [
        // sort by someField in ascending order...
        {field: someField},
        // then by someOtherField in descending order
        {field: someOtherField, direction: 'desc'},
    ],
});
```

##### fields

Generally, it's a good idea to load as little data into your block as possible - Airtable bases can
get pretty big, and we have to keep all that information in memory and up to date if you ask for it.
The fields option lets you make sure that only data relevant to you is loaded.

You can specify fields with a [Field][16], by ID, or by name:

```js
view.selectRecords({
    fields: [
        // we want to only load fieldA:
        fieldA,
        // the field with this id:
        'fldXXXXXXXXXXXXXX',
        // and the field named 'Rating':
        'Rating',
    ],
});
```

##### recordColorMode

Just like a view in Airtable, you can control the colors of records in a field. There are three
supported record color modes:

By taking the colors the records have according to the rules of a specific view:

```js
import {recordColoring} from '@airtable/blocks/models';

someTable.selectRecords({
    recordColorMode: recordColoring.modes.byView(someView),
});
```

Based on the color of a single select field in the table:

```js
import {recordColoring} from '@airtable/blocks/models';

someView.selectRecords({
    recordColorMode: recordColoring.modes.bySelectField(someSelectField),
});
```

By default, views will have whichever coloring is set up in Airtable and tables won't have any
record coloring:

```js
// these two are the same:
someView.selectRecords();
someView.selectRecords({
    recordColorMode: recordColoring.modes.byView(someView),
});

// as are these two:
someTable.selectRecords();
someTable.selectRecords({
    recordColorMode: recordColoring.modes.none(),
});
```

##### fields

The fields that were used to create this QueryResult. Null if fields were not specified, which means
the QueryResult will load all fields in the table.

Type: ([Array][66]&lt;[Field][81]> | null)

Returns **([Array][66]&lt;[Field][81]> | null)**

##### getRecordById

Get a specific record in the query result, or throws if that record doesn't exist or is filtered
out. Throws if data is not loaded yet. Watch using `'recordIds'`.

###### Parameters

-   `recordId` **RecordId** the ID of the [Record][18] you want

Returns **[Record][84]** the record

##### getRecordByIdIfExists

Get a specific record in the query result, or null if that record doesn't exist or is filtered out.
Throws if data is not loaded yet. Watch using `'recordIds'`.

###### Parameters

-   `recordId` **RecordId** the ID of the [Record][18] you want

Returns **([Record][84] | null)** the record

##### getRecordColor

Get the color of a specific record in the query result. Throws if the record isn't in the
RecordQueryResult. Watch with the `'recordColors'` and `'recordIds` keys.

###### Parameters

-   `recordOrRecordId` **(RecordId | [Record][84])** the record or record ID you want the color of.

Returns **([Color][97] | null)** a [Color][98], or null if the record has no color in this query
result.

##### hasRecord

Check to see if a particular record or record id is present in this query result. Returns false if
the record has been deleted or is filtered out.

###### Parameters

-   `recordOrRecordId` **(RecordId | [Record][84])** the record or record id to check the presence
    of

Returns **[boolean][69]** whether the record exists in this query result

##### loadDataAsync

Loads all data for the query result.

Every call to `loadDataAsync` should have a matching call to `unloadData`.

Returns **[Promise][70]&lt;void>** A promise that will resolve once the data is loaded.

##### recordIds

The record IDs in this QueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][66]&lt;RecordId>

Returns **[Array][66]&lt;RecordId>**

##### records

The records in this RecordQueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][66]&lt;[Record][84]>

Returns **[Array][66]&lt;[Record][84]>** all of the records in this query result

##### unloadData

Unloads data for the query result.

Every call to `loadDataAsync` should have a matching call to `unloadData`.

Returns **void**

##### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

Unwatching a key that needs to load data asynchronously will automatically cause the data to be
unloaded.

###### Parameters

-   `keys` **(WatchableRecordQueryResultKey | [Array][66]&lt;WatchableRecordQueryResultKey>)** the
    keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableRecordQueryResultKey>** the array of keys that were unwatched

##### watch

Get notified of changes to the query result.

Watchable keys are:

-   `'records'`
-   `'recordIds'`
-   `'cellValues'`
-   `'recordColors'`
-   `'isDataLoaded'`
-   `'cellValuesInField:' + someFieldId`

Every call to `.watch` should have a matching call to `.unwatch`.

Watching a key that needs to load data asynchronously will automatically cause the data to be
fetched. Once the data is available, the `callback` will be called.

###### Parameters

-   `keys` **(WatchableRecordQueryResultKey | [Array][66]&lt;WatchableRecordQueryResultKey>)** the
    keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableRecordQueryResultKey>** the array of keys that were watched

#### TableOrViewQueryResult

**Extends RecordQueryResult**

Represents a set of records directly from a view or table. See [RecordQueryResult][17] for main
documentation.

Do not instantiate. You can get instances of this class by calling `table.selectRecords` or
`view.selectRecords`.

##### Parameters

-   `sourceModel` **([Table][86] \| [View][82])**
-   `normalizedOpts` **NormalizedRecordQueryResultOpts**

##### fields

The fields that were used to create this RecordQueryResult. Null if fields were not specified, which
means the RecordQueryResult will load all fields in the table.

Type: ([Array][66]&lt;[Field][81]> | null)

Returns **([Array][66]&lt;[Field][81]> | null)**

##### recordIds

The record IDs in this RecordQueryResult. Throws if data is not loaded yet. Can be watched.

Type: [Array][66]&lt;[string][65]>

Returns **[Array][66]&lt;[string][65]>**

#### LinkedRecordsQueryResult

**Extends RecordQueryResult**

Represents a set of records from a LinkedRecord cell value. See [RecordQueryResult][17] for main
documentation.

Do not instantiate. You can get instances of this class by calling
`record.getLinkedRecordsFromCell`.

##### Parameters

-   `record` **[Record][84]**
-   `field` **[Field][81]**
-   `normalizedOpts` **NormalizedRecordQueryResultOpts**

##### fields

Type: ([Array][66]&lt;[Field][81]> | null)

Returns **([Array][66]&lt;[Field][81]> | null)** The fields that were used to create this
LinkedRecordsQueryResult.

##### isValid

Is the query result currently valid? This value always starts as 'true', but can become false if the
field config changes to link to a different table or a type other than MULTIPLE_RECORD_LINKS. Once
`isValid` has become false, it will never become true again. Many fields will throw on attempting to
access them, and watches will no longer fire.

Type: [boolean][69]

Returns **[boolean][69]** whether the query result is valid

##### recordIds

Watchable.

Type: [Array][66]&lt;[string][65]>

Returns **[Array][66]&lt;[string][65]>** Ordered array of all the linked record ids.

##### records

Watchable.

Type: [Array][66]&lt;[Record][84]>

Returns **[Array][66]&lt;[Record][84]>** Ordered array of all the linked records.

### Record

**Extends AbstractModel**

Model class representing a record in a table.

Do not instantiate. You can get instances of this class by calling `table.selectRecords` or
`view.selectRecords` and using the resulting {@RecordQueryResult}.

#### commentCount

Type: [number][73]

##### Examples

```javascript
const comentCount = myRecord.commentCount;
console.log(`This record has ${commentCount} ${commentCount === 1 ? 'comment' : 'comments'}`);
```

Returns **[number][73]** The number of comments on this record.

#### createdTime

Type: [Date][99]

##### Examples

```javascript
console.log(`This record was created at ${myRecord.createdTime.toISOString()}`);
```

Returns **[Date][99]** The created time of this record.

#### getAttachmentClientUrlFromCellValueUrl

Returns a URL that is suitable for rendering an attachment on the current client. The URL that is
returned will only work for the current user.

##### Parameters

-   `attachmentId` **[string][65]** The ID of the attachment.
-   `attachmentUrl` **[string][65]** The attachment's URL (which is not suitable for rendering on
    the client).

##### Examples

```javascript
import React from 'react';

function RecordAttachments(props) {
    const {record, attachmentField} = props;
    const attachmentCellValue = record.getCellValue(attachmentField);
    if (attachmentCellValue === null) {
        return null;
    }
    return (
        <div>
            {attachmentCellValue.map(attachmentObj => {
                const clientUrl = record.getAttachmentClientUrlFromCellValueUrl(
                    attachmentObj.id,
                    attachmentObj.url,
                );
                return <img key={attachmentObj.id} src={clientUrl} width={200} />;
            })}
        </div>
    );
}
```

Returns **[string][65]** A URL that is suitable for rendering on the current client.

#### getCellValue

Gets a specific cell value in this record.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][81] | FieldId | [string][65])** The field (or field ID or
    field name) whose cell value you'd like to get.

##### Examples

```javascript
const cellValue = myRecord.getCellValue(mySingleLineTextField);
console.log(cellValue);
// => 'cell value'
```

Returns **any** The cell value in the given field.

#### getCellValueAsString

Gets a specific cell value in this record, formatted as a `string`.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][81] | FieldId | [string][65])** The field (or field ID or
    field name) whose cell value you'd like to get.

##### Examples

```javascript
const cellValueAsString = myRecord.getCellValueAsString(myNumberField);
console.log(cellValueAsString);
// => '42'
```

Returns **[string][65]** The cell value in the given field, formatted as a `string`.

#### getColorHexInView

Gets the CSS hex string for this record in a given view.

Can be watched with the 'colorInView:\${ViewId}' key.

##### Parameters

-   `viewOrViewIdOrViewName` **([View][82] \| [string][65])** The view (or view ID or view name) to
    use for record coloring.

Returns **([string][65] | null)** The CSS hex color for this record in the given view, or null if
the record has no color in that view.

#### getColorInView

Gets the color of this record in a given view.

Can be watched with the 'colorInView:\${ViewId}' key.

##### Parameters

-   `viewOrViewIdOrViewName` **([View][82] | ViewId | [string][65])** The view (or view ID or view
    name) to use for record coloring.

Returns **([Color][97] | null)** The color of this record in the given view, or null if the record
has no color in that view.

#### id

##### Examples

```javascript
console.log(myRecord.id);
// => 'recxxxxxxxxxxxxxx'
```

Returns **[string][65]** This record's ID.

#### isDeleted

True if this record has been deleted.

In general, it's best to avoid keeping a reference to a record past the current event loop, since it
may be deleted and trying to access any data of a deleted record (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the record's
data.

##### Examples

```javascript
if (!myRecord.isDeleted) {
    // Do things with myRecord
}
```

Returns **[boolean][69]** `true` if the record has been deleted, `false` otherwise.

#### primaryCellValue

Gets the primary cell value in this record.

Type: any

##### Examples

```javascript
console.log(myRecord.primaryCellValue);
// => 'primary cell value'
```

Returns **any** The primary cell value in this record.

#### primaryCellValueAsString

Gets the primary cell value in this record, formatted as a `string`.

Type: [string][65]

##### Examples

```javascript
console.log(myRecord.primaryCellValueAsString);
// => '42'
```

Returns **[string][65]** The primary cell value in this record, formatted as a `string`.

#### selectLinkedRecordsFromCell

Select records referenced in a `multipleRecordLinks` cell value. Returns a query result. See
[RecordQueryResult][17] for more.

##### Parameters

-   `fieldOrFieldIdOrFieldName` **([Field][81] | FieldId | [string][65])** The `multipleRecordLinks`
    field (or field ID or field name) to use.
-   `opts` **RecordQueryResultOpts** Options for the query, such as sorts and fields. (optional,
    default `{}`)

Returns **[LinkedRecordsQueryResult][100]** A query result containing the records in the given
`multipleRecordLinks` field.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableRecordKey | [Array][66]&lt;WatchableRecordKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableRecordKey>** the array of keys that were unwatched

#### url

Type: [string][65]

##### Examples

```javascript
console.log(myRecord.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx/recxxxxxxxxxxxxxx'
```

Returns **[string][65]** The URL for the record. You can visit this URL in the browser to be taken
to the record in the Airtable UI.

#### watch

Get notified of changes to the record.

Watchable keys are:

-   `'primaryCellValue'`
-   `'commentCount'`
-   `'cellValues'`
-   `'cellValueInField:' + someFieldId`
-   `'colorInView:' + someViewId`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableRecordKey | [Array][66]&lt;WatchableRecordKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableRecordKey>** the array of keys that were watched

### Table

**Extends AbstractModel**

Model class representing a table. Every [Base][13] has one or more tables.

#### checkPermissionsForCreateRecord

Checks whether the current user has permission to create the specified record.

Accepts partial input, in the same format as [createRecordAsync][101]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `fields` **[object][72]?** object mapping `FieldId` or field name to value for that field.

##### Examples

```javascript
// Check if user can create a specific record, when you already know what fields/cell values
// will be set for the record.
const createRecordCheckResult = table.checkPermissionsForCreateRecord({
    'Project Name': 'Advertising campaign',
    Budget: 100,
});
if (!createRecordCheckResult.hasPermission) {
    alert(createRecordCheckResult.reasonDisplayString);
}

// Like createRecordAsync, you can use either field names or field IDs.
const createRecordCheckResultWithFieldIds = table.checkPermissionsForCreateRecord({
    [projectNameField.id]: 'Cat video',
    [budgetField.id]: 200,
});

// Check if user could potentially create a record.
// Use when you don't know the specific fields/cell values yet (for example, to show or hide
// UI controls that let you start creating a record.)
const createUnknownRecordCheckResult = table.checkPermissionsForCreateRecord();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can create the specified record, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### checkPermissionsForCreateRecords

Checks whether the current user has permission to create the specified records.

Accepts partial input, in the same format as [createRecordsAsync][102]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `records` **[Array][66]&lt;[object][72]>?** Array of objects mapping `FieldId` or field name to
    value for that field.

##### Examples

```javascript
// Check if user can create specific records, when you already know what fields/cell values
// will be set for the records.
const createRecordsCheckResult = table.checkPermissionsForCreateRecords([
    // Like createRecordsAsync, fields can be specified by name or ID
    {
        'Project Name': 'Advertising campaign',
        Budget: 100,
    },
    {
        [projectNameField.id]: 'Cat video',
        [budgetField.id]: 200,
    },
    {},
]);
if (!createRecordsCheckResult.hasPermission) {
    alert(createRecordsCheckResult.reasonDisplayString);
}

// Check if user could potentially create records.
// Use when you don't know the specific fields/cell values yet (for example, to show or hide
// UI controls that let you start creating records.)
// Equivalent to table.checkPermissionsForCreateRecord()
const createUnknownRecordCheckResult = table.checkPermissionsForCreateRecords();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can create the specified records, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### checkPermissionsForDeleteRecord

Checks whether the current user has permission to delete the specified record.

Accepts optional input, in the same format as [deleteRecordAsync][103]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)?** the record to be deleted

##### Examples

```javascript
// Check if user can delete a specific record
const deleteRecordCheckResult = table.checkPermissionsForDeleteRecord(record);
if (!deleteRecordCheckResult.hasPermission) {
    alert(deleteRecordCheckResult.reasonDisplayString);
}

// Check if user could potentially delete a record.
// Use when you don't know the specific record you want to delete yet (for example, to show
// or hide UI controls that let you select a record to delete.)
const deleteUnknownRecordCheckResult = table.checkPermissionsForDeleteRecord();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can delete the specified record, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### checkPermissionsForDeleteRecords

Checks whether the current user has permission to delete the specified records.

Accepts optional input, in the same format as [deleteRecordsAsync][104]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordsOrRecordIds` **[Array][66]&lt;([Record][84] | RecordId)>?** the records to be deleted

##### Examples

```javascript
// Check if user can delete specific records
const deleteRecordsCheckResult = table.checkPermissionsForDeleteRecords([record1, record2]);
if (!deleteRecordsCheckResult.hasPermission) {
    alert(deleteRecordsCheckResult.reasonDisplayString);
}

// Check if user could potentially delete records.
// Use when you don't know the specific records you want to delete yet (for example, to show
// or hide UI controls that let you select records to delete.)
// Equivalent to table.hasPermissionToDeleteRecord()
const deleteUnknownRecordsCheckResult = table.checkPermissionsForDeleteRecords();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can delete the specified records, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### checkPermissionsForUpdateRecord

Checks whether the current user has permission to perform the given record update.

Accepts partial input, in the same format as [updateRecordAsync][105]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)?** the record to update
-   `fields` **[object][72]?** cell values to update in that record, specified as object mapping
    `FieldId` or field name to value for that field.

##### Examples

```javascript
// Check if user can update specific fields for a specific record.
const updateRecordCheckResult = table.checkPermissionsForUpdateRecord(record, {
    'Post Title': 'How to make: orange-mango pound cake',
    'Publication Date': '2020-01-01',
});
if (!updateRecordCheckResult.hasPermission) {
    alert(updateRecordCheckResult.reasonDisplayString);
}

// Like updateRecordAsync, you can use either field names or field IDs.
const updateRecordCheckResultWithFieldIds = table.checkPermissionsForUpdateRecord(record, {
    [postTitleField.id]: 'Cake decorating tips & tricks',
    [publicationDateField.id]: '2020-02-02',
});

// Check if user could update a given record, when you don't know the specific fields that
// will be updated yet. (for example, to check whether you should allow a user to select
// a certain record to update)
const updateUnknownFieldsCheckResult = table.checkPermissionsForUpdateRecord(record);

// Check if user could update specific fields, when you don't know the specific record that
// will be updated yet. (for example, if the field is selected by the user and you want to
// check if your block can write to it)
const updateUnknownRecordCheckResult = table.checkPermissionsForUpdateRecord(undefined, {
    'My field name': 'updated value',
    // You can use undefined if you know you're going to update a field, but don't know
    // the new cell value yet.
    'Another field name': undefined,
});

// Check if user could perform updates within the table, without knowing the specific record
// or fields that will be updated yet. (for example, to render your block in "read only"
// mode)
const updateUnknownRecordAndFieldsCheckResult = table.checkPermissionsForUpdateRecord();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can update the specified record, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### checkPermissionsForUpdateRecords

Checks whether the current user has permission to perform the given record updates.

Accepts partial input, in the same format as [updateRecordsAsync][106]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `records` **(\$ReadOnlyArray&lt;{id: (RecordId | void)?, fields: ({} | void)?}> | void)?**

##### Examples

```javascript
const recordsToUpdate = [
    {
        // Validating a complete record update
        id: record1.id,
        fields: {
            'Post Title': 'How to make: orange-mango pound cake',
            'Publication Date': '2020-01-01',
        },
    },
    {
        // Like updateRecordsAsync, fields can be specified by name or ID
        id: record2.id,
        fields: {
            [postTitleField.id]: 'Cake decorating tips & tricks',
            [publicationDateField.id]: '2020-02-02',
        },
    },
    {
        // Validating an update to a specific record, not knowing what fields will be updated
        id: record3.id,
    },
    {
        // Validating an update to specific cell values, not knowing what record will be updated
        fields: {
            'My field name': 'updated value for unknown record',
            // You can use undefined if you know you're going to update a field, but don't know
            // the new cell value yet.
            'Another field name': undefined,
        },
    },
];

const updateRecordsCheckResult = table.checkPermissionsForUpdateRecords(recordsToUpdate);
if (!updateRecordsCheckResult.hasPermission) {
    alert(updateRecordsCheckResult.reasonDisplayString);
}

// Check if user could potentially update records.
// Equivalent to table.checkPermissionsForUpdateRecord()
const updateUnknownRecordAndFieldsCheckResult = table.checkPermissionsForUpdateRecords();
```

Returns **PermissionCheckResult** PermissionCheckResult `{hasPermission: true}` if the current user
can update the specified records, `{hasPermission: false, reasonDisplayString: string}` otherwise.
`reasonDisplayString` may be used to display an error message to the user.

#### createRecordAsync

Creates a new record with the specified cell values.

Throws an error if the user does not have permission to create the given records, or if invalid
input is provided (eg. invalid cell values).

This action is asynchronous: `await` the returned promise if you wish to wait for the new record to
be persisted to Airtable servers. Updates are applied optimistically locally, so your changes will
be reflected in your block before the promise resolves.

##### Parameters

-   `fields` **[object][72]** object mapping `FieldId` or field name to value for that field.
    (optional, default `{}`)

##### Examples

```javascript
function createNewRecord(recordFields) {
    if (table.hasPermissionToCreateRecord(recordFields)) {
        table.createRecordAsync(recordFields);
    }
    // You can now access the new record in your block (eg `table.selectRecords()`) but it is
    // still being saved to Airtable servers (eg. other users may not be able to see it yet.)
}

async function createNewRecordAsync(recordFields) {
    if (table.hasPermissionToCreateRecord(recordFields)) {
        const newRecordId = await table.createRecordAsync(recordFields);
    }
    // New record has been saved to Airtable servers.
    alert(`new record with ID ${newRecordId} has been created`);
}

// Fields can be specified by name or ID
createNewRecord({
    'Project Name': 'Advertising campaign',
    Budget: 100,
});
createNewRecord({
    [projectNameField.id]: 'Cat video',
    [budgetField.id]: 200,
});
```

Returns **[Promise][70]&lt;RecordId>** A promise that will resolve to the RecordId of the new
record, once the new record is persisted to Airtable.

#### createRecordsAsync

Creates new records with the specified cell values.

Throws an error if the user does not have permission to create the given records, or if invalid
input is provided (eg. invalid cell values).

You may only create up to 50 records in one call to `createRecordsAsync`. See [Writing changes to
records][107] for more information about write limits.

This action is asynchronous: `await` the returned promise if you wish to wait for the new record to
be persisted to Airtable servers. Updates are applied optimistically locally, so your changes will
be reflected in your block before the promise resolves.

##### Parameters

-   `records` **[Array][66]&lt;[object][72]>** Array of objects mapping `FieldId` or field name to
    value for that field.

##### Examples

```javascript
const recordDefs = [
    // Fields can be specified by name or ID
    {
        'Project Name': 'Advertising campaign',
        Budget: 100,
    },
    {
        [projectNameField.id]: 'Cat video',
        [budgetField.id]: 200,
    },
    // Specifying no fields will create a new record with no cell values set
    {},
];

function createNewRecords() {
    if (table.hasPermissionToCreateRecords(recordDefs)) {
        table.createRecordsAsync(recordDefs);
    }
    // You can now access the new records in your block (eg `table.selectRecords()`) but they
    // are still being saved to Airtable servers (eg. other users may not be able to see them
    // yet.)
}

async function createNewRecordsAsync() {
    if (table.hasPermissionToCreateRecords(recordDefs)) {
        const newRecordIds = await table.createRecordsAsync(recordDefs);
    }
    // New records have been saved to Airtable servers.
    alert(`new records with IDs ${newRecordIds} have been created`);
}
```

Returns **[Promise][70]&lt;[Array][66]&lt;RecordId>>** A promise that will resolve to array of
RecordIds of the new records, once the new records are persisted to Airtable.

#### deleteRecordAsync

Delete the given record.

Throws an error if the user does not have permission to delete the given record.

This action is asynchronous: `await` the returned promise if you wish to wait for the delete to be
persisted to Airtable servers. Updates are applied optimistically locally, so your changes will be
reflected in your block before the promise resolves.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)** the record to be deleted

##### Examples

```javascript
function deleteRecord(record) {
    if (table.hasPermissionToDeleteRecord(record)) {
        table.deleteRecordAsync(record);
    }
    // The record is now deleted within your block (eg will not be returned in
    // `table.selectRecords`) but it is still being saved to Airtable servers (eg. it may
    // not look deleted to other users yet)
}

async function deleteRecordAsync(record) {
    if (table.hasPermissionToDeleteRecord(record)) {
        await table.deleteRecordAsync(record);
    }
    // Record deletion has been saved to Airtable servers.
    alert('record has been deleted');
}
```

Returns **[Promise][70]&lt;void>** A promise that will resolve once the delete is persisted to
Airtable.

#### deleteRecordsAsync

Delete the given records.

Throws an error if the user does not have permission to delete the given records.

You may only delete up to 50 records in one call to `deleteRecordsAsync`. See [Writing changes to
records][107] for more information about write limits.

This action is asynchronous: `await` the returned promise if you wish to wait for the delete to be
persisted to Airtable servers. Updates are applied optimistically locally, so your changes will be
reflected in your block before the promise resolves.

##### Parameters

-   `recordsOrRecordIds` **[Array][66]&lt;([Record][84] | RecordId)>** Array of Records and
    RecordIds

##### Examples

```javascript
function deleteRecords(records) {
    if (table.hasPermissionToDeleteRecords(records)) {
        table.deleteRecordsAsync(records);
    }
    // The records are now deleted within your block (eg will not be returned in
    // `table.selectRecords()`) but are still being saved to Airtable servers (eg. they
    // may not look deleted to other users yet)
}

async function deleteRecordsAsync(records) {
    if (table.hasPermissionToDeleteRecords(records)) {
        await table.deleteRecordsAsync(records);
    }
    // Record deletions have been saved to Airtable servers.
    alert('records have been deleted');
}
```

Returns **[Promise][70]&lt;void>** A promise that will resolve once the deletes are persisted to
Airtable.

#### fields

Type: [Array][66]&lt;[Field][81]>

##### Examples

```javascript
console.log(`This table has ${myTable.fields.length} fields`);
```

Returns **[Array][66]&lt;[Field][81]>** The fields in this table. The order is arbitrary, since
fields are only ordered in the context of a specific view.Can be watched to know when fields are
created or deleted.

#### getFieldById

##### Parameters

-   `fieldId` **FieldId** The ID of the field.

##### Examples

```javascript
const fieldId = 'fldxxxxxxxxxxxxxx';
const field = myTable.getFieldById(fieldId);
console.log(field.name);
// => 'Name'
```

Returns **[Field][81]** The field matching the given ID. Throws if that field does not exist in this
table. Use [getFieldByIdIfExists][108] instead if you are unsure whether a field exists with the
given ID.

#### getFieldByIdIfExists

##### Parameters

-   `fieldId` **FieldId** The ID of the field.

##### Examples

```javascript
const fieldId = 'fldxxxxxxxxxxxxxx';
const field = myTable.getFieldByIdIfExists(fieldId);
if (field !== null) {
    console.log(field.name);
} else {
    console.log('No field exists with that ID');
}
```

Returns **([Field][81] | null)** The field matching the given ID, or `null` if that field does not
exist in this table.

#### getFieldByName

##### Parameters

-   `fieldName` **[string][65]** The name of the field you're looking for.

##### Examples

```javascript
const field = myTable.getFieldByName('Name');
console.log(field.id);
// => 'fldxxxxxxxxxxxxxx'
```

Returns **[Field][81]** The field matching the given name. Throws if no field exists with that name
in this table. Use [getFieldByNameIfExists][109] instead if you are unsure whether a field exists
with the given name.

#### getFieldByNameIfExists

##### Parameters

-   `fieldName` **[string][65]** The name of the field you're looking for.

##### Examples

```javascript
const field = myTable.getFieldByNameIfExists('Name');
if (field !== null) {
    console.log(field.id);
} else {
    console.log('No field exists with that name');
}
```

Returns **([Field][81] | null)** The field matching the given name, or `null` if no field exists
with that name in this table.

#### getFirstViewOfType

Returns the first view in the table where the type is one of `allowedViewTypes`.

##### Parameters

-   `allowedViewTypes` **([Array][66]&lt;ViewType> | ViewType)** An array of view types or a single
    view type to match against.
-   `preferredViewOrViewId` **([View][82] | ViewId | null)?** If a view or view ID is supplied and
    that view exists & has the correct type, that view will be returned before checking the other
    views in the table.

##### Examples

```javascript
import {viewTypes} from '@airtable/blocks/models';
const firstCalendarView = myTable.getFirstViewOfType(viewTypes.CALENDAR);
if (firstCalendarView !== null) {
    console.log(firstCalendarView.name);
} else {
    console.log('No calendar views exist in the table');
}
```

Returns **([View][82] | null)** The first view where the type is one of `allowedViewTypes` or `null`
if no such view exists in the table.

#### getViewById

##### Parameters

-   `viewId` **ViewId** The ID of the view.

##### Examples

```javascript
const viewId = 'viwxxxxxxxxxxxxxx';
const view = myTable.getViewById(viewId);
console.log(view.name);
// => 'Grid view'
```

Returns **[View][82]** The view matching the given ID. Throws if that view does not exist in this
table. Use [getViewByIdIfExists][110] instead if you are unsure whether a view exists with the given
ID.

#### getViewByIdIfExists

##### Parameters

-   `viewId` **ViewId** The ID of the view.

##### Examples

```javascript
const viewId = 'viwxxxxxxxxxxxxxx';
const view = myTable.getViewByIdIfExists(viewId);
if (view !== null) {
    console.log(view.name);
} else {
    console.log('No view exists with that ID');
}
```

Returns **([View][82] | null)** The view matching the given ID, or `null` if that view does not
exist in this table.

#### getViewByName

##### Parameters

-   `viewName` **[string][65]** The name of the view you're looking for.

##### Examples

```javascript
const view = myTable.getViewByName('Name');
console.log(view.id);
// => 'viwxxxxxxxxxxxxxx'
```

Returns **[View][82]** The view matching the given name. Throws if no view exists with that name in
this table. Use [getViewByNameIfExists][111] instead if you are unsure whether a view exists with
the given name.

#### getViewByNameIfExists

##### Parameters

-   `viewName` **[string][65]** The name of the view you're looking for.

##### Examples

```javascript
const view = myTable.getViewByNameIfExists('Name');
if (view !== null) {
    console.log(view.id);
} else {
    console.log('No view exists with that name');
}
```

Returns **([View][82] | null)** The view matching the given name, or `null` if no view exists with
that name in this table.

#### hasPermissionToCreateRecord

An alias for `checkPermissionsForCreateRecord(fields).hasPermission`.

Checks whether the current user has permission to create the specified record.

Accepts partial input, in the same format as [createRecordAsync][101]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `fields` **[object][72]?** object mapping `FieldId` or field name to value for that field.

##### Examples

```javascript
// Check if user can create a specific record, when you already know what fields/cell values
// will be set for the record.
const canCreateRecord = table.hasPermissionToCreateRecord({
    'Project Name': 'Advertising campaign',
    Budget: 100,
});
if (!canCreateRecord) {
    alert('not allowed!');
}

// Like createRecordAsync, you can use either field names or field IDs.
const canCreateRecordWithFieldIds = table.hasPermissionToCreateRecord({
    [projectNameField.id]: 'Cat video',
    [budgetField.id]: 200,
});

// Check if user could potentially create a record.
// Use when you don't know the specific fields/cell values yet (for example, to show or hide
// UI controls that let you start creating a record.)
const canCreateUnknownRecord = table.hasPermissionToCreateRecord();
```

Returns **[boolean][69]** boolean Whether the current user can create the specified record.

#### hasPermissionToCreateRecords

An alias for `checkPermissionsForCreateRecords(records).hasPermission`.

Checks whether the current user has permission to create the specified records.

Accepts partial input, in the same format as [createRecordsAsync][102]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `records` **[Array][66]&lt;[object][72]>?** Array of objects mapping `FieldId` or field name to
    value for that field.

##### Examples

```javascript
// Check if user can create specific records, when you already know what fields/cell values
// will be set for the records.
const canCreateRecords = table.hasPermissionToCreateRecords([
    // Like createRecordsAsync, fields can be specified by name or ID
    {
        'Project Name': 'Advertising campaign',
        Budget: 100,
    },
    {
        [projectNameField.id]: 'Cat video',
        [budgetField.id]: 200,
    },
    {},
]);
if (!canCreateRecords) {
    alert('not allowed');
}

// Check if user could potentially create records.
// Use when you don't know the specific fields/cell values yet (for example, to show or hide
// UI controls that let you start creating records.)
// Equivalent to table.hasPermissionToCreateRecord()
const canCreateUnknownRecords = table.hasPermissionToCreateRecords();
```

Returns **[boolean][69]** boolean Whether the current user can create the specified records.

#### hasPermissionToDeleteRecord

An alias for `checkPermissionsForDeleteRecord(recordOrRecordId).hasPermission`.

Checks whether the current user has permission to delete the specified record.

Accepts optional input, in the same format as [deleteRecordAsync][103]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)?** the record to be deleted

##### Examples

```javascript
// Check if user can delete a specific record
const canDeleteRecord = table.hasPermissionToDeleteRecord(record);
if (!canDeleteRecord) {
    alert('not allowed');
}

// Check if user could potentially delete a record.
// Use when you don't know the specific record you want to delete yet (for example, to show
// or hide UI controls that let you select a record to delete.)
const canDeleteUnknownRecord = table.hasPermissionToDeleteRecord();
```

Returns **[boolean][69]** boolean Whether the current user can delete the specified record.

#### hasPermissionToDeleteRecords

An alias for `checkPermissionsForDeleteRecords(recordsOrRecordIds).hasPermission`.

Checks whether the current user has permission to delete the specified records.

Accepts optional input, in the same format as [deleteRecordsAsync][104]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordsOrRecordIds` **[Array][66]&lt;([Record][84] | RecordId)>?** the records to be deleted

##### Examples

```javascript
// Check if user can delete specific records
const canDeleteRecords = table.hasPermissionToDeleteRecords([record1, record2]);
if (!canDeleteRecords) {
    alert('not allowed!');
}

// Check if user could potentially delete records.
// Use when you don't know the specific records you want to delete yet (for example, to show
// or hide UI controls that let you select records to delete.)
// Equivalent to table.hasPermissionToDeleteRecord()
const canDeleteUnknownRecords = table.hasPermissionToDeleteRecords();
```

Returns **[boolean][69]** boolean Whether the current user can delete the specified records.

#### hasPermissionToUpdateRecord

An alias for `checkPermissionsForUpdateRecord(recordOrRecordId, fields).hasPermission`.

Checks whether the current user has permission to perform the given record update.

Accepts partial input, in the same format as [updateRecordAsync][105]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)?** the record to update
-   `fields` **[object][72]?** cell values to update in that record, specified as object mapping
    `FieldId` or field name to value for that field.

##### Examples

```javascript
// Check if user can update specific fields for a specific record.
const canUpdateRecord = table.hasPermissionToUpdateRecord(record, {
    'Post Title': 'How to make: orange-mango pound cake',
    'Publication Date': '2020-01-01',
});
if (!canUpdateRecord) {
    alert('not allowed!');
}

// Like updateRecordAsync, you can use either field names or field IDs.
const canUpdateRecordWithFieldIds = table.hasPermissionToUpdateRecord(record, {
    [postTitleField.id]: 'Cake decorating tips & tricks',
    [publicationDateField.id]: '2020-02-02',
});

// Check if user could update a given record, when you don't know the specific fields that
// will be updated yet. (for example, to check whether you should allow a user to select
// a certain record to update)
const canUpdateUnknownFields = table.hasPermissionToUpdateRecord(record);

// Check if user could update specific fields, when you don't know the specific record that
// will be updated yet. (for example, if the field is selected by the user and you want to
// check if your block can write to it)
const canUpdateUnknownRecord = table.hasPermissionToUpdateRecord(undefined, {
    'My field name': 'updated value',
    // You can use undefined if you know you're going to update a field, but don't know
    // the new cell value yet.
    'Another field name': undefined,
});

// Check if user could perform updates within the table, without knowing the specific record
// or fields that will be updated yet. (for example, to render your block in "read only"
// mode)
const canUpdateUnknownRecordAndFields = table.hasPermissionToUpdateRecord();
```

Returns **[boolean][69]** boolean Whether the user can update the specified record.

#### hasPermissionToUpdateRecords

An alias for `checkPermissionsForUpdateRecords(records).hasPermission`.

Checks whether the current user has permission to perform the given record updates.

Accepts partial input, in the same format as [updateRecordsAsync][106]. The more information
provided, the more accurate the permissions check will be.

##### Parameters

-   `records` **(\$ReadOnlyArray&lt;{id: (RecordId | void)?, fields: ({} | void)?}> | void)?**

##### Examples

```javascript
const recordsToUpdate = [
    {
        // Validating a complete record update
        id: record1.id,
        fields: {
            'Post Title': 'How to make: orange-mango pound cake',
            'Publication Date': '2020-01-01',
        },
    },
    {
        // Like updateRecordsAsync, fields can be specified by name or ID
        id: record2.id,
        fields: {
            [postTitleField.id]: 'Cake decorating tips & tricks',
            [publicationDateField.id]: '2020-02-02',
        },
    },
    {
        // Validating an update to a specific record, not knowing what fields will be updated
        id: record3.id,
    },
    {
        // Validating an update to specific cell values, not knowing what record will be updated
        fields: {
            'My field name': 'updated value for unknown record',
            // You can use undefined if you know you're going to update a field, but don't know
            // the new cell value yet.
            'Another field name': undefined,
        },
    },
];

const canUpdateRecords = table.hasPermissionToUpdateRecords(recordsToUpdate);
if (!canUpdateRecords) {
    alert('not allowed');
}

// Check if user could potentially update records.
// Equivalent to table.hasPermissionToUpdateRecord()
const canUpdateUnknownRecordsAndFields = table.hasPermissionToUpdateRecords();
```

Returns **[boolean][69]** boolean Whether the current user can update the specified records.

#### id

##### Examples

```javascript
console.log(myTable.id);
// => 'tblxxxxxxxxxxxxxx'
```

Returns **[string][65]** This table's ID.

#### isDeleted

True if this table has been deleted.

In general, it's best to avoid keeping a reference to a table past the current event loop, since it
may be deleted and trying to access any data of a deleted table (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the table's
data.

##### Examples

```javascript
if (!myTable.isDeleted) {
    // Do things with myTable
}
```

Returns **[boolean][69]** `true` if the table has been deleted, `false` otherwise.

#### name

Type: [string][65]

##### Examples

```javascript
console.log(myTable.name);
// => 'Table 1'
```

Returns **[string][65]** The name of the table. Can be watched.

#### primaryField

Type: [Field][81]

##### Examples

```javascript
console.log(myTable.primaryField.name);
// => 'Name'
```

Returns **[Field][81]** The table's primary field. Every table has exactly one primary field. The
primary field of a table will not change.

#### selectRecords

Select records from the table. Returns a query result. See [RecordQueryResult][17] for more.

##### Parameters

-   `opts` **RecordQueryResultOpts?** Options for the query, such as sorts and fields. (optional,
    default `{}`)

##### Examples

```javascript
import {UI} from '@airtable/blocks';
import React from 'react';

function TodoList() {
    const base = UI.useBase();
    const table = base.getTableByName('Tasks');

    const queryResult = table.selectRecords();
    const records = UI.useRecords(queryResult);

    return (
        <ul>
            {records.map(record => (
                <li key={record.id}>{record.primaryCellValueAsString || 'Unnamed record'}</li>
            ))}
        </ul>
    );
}
```

Returns **[TableOrViewQueryResult][112]** A query result.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableTableKey | [Array][66]&lt;WatchableTableKey>)** the keys to unwatch
-   `callback` **[Function][71]** the function passed to `.watch` for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableTableKey>** the array of keys that were unwatched

#### updateRecordAsync

Updates cell values for a record.

Throws an error if the user does not have permission to update the given cell values in the record,
or if invalid input is provided (eg. invalid cell values).

This action is asynchronous: `await` the returned promise if you wish to wait for the updated cell
values to be persisted to Airtable servers. Updates are applied optimistically locally, so your
changes will be reflected in your block before the promise resolves.

##### Parameters

-   `recordOrRecordId` **([Record][84] | RecordId)** the record to update
-   `fields` **[object][72]** cell values to update in that record, specified as object mapping
    `FieldId` or field name to value for that field.

##### Examples

```javascript
function updateRecord(record, recordFields) {
    if (table.hasPermissionToUpdateRecord(record, recordFields)) {
        table.updateRecordAsync(record, recordFields);
    }
    // The updated values will now show in your block (eg in `table.selectRecords()` result)
    // but are still being saved to Airtable servers (eg. other users may not be able to see
    // them yet.)
}

async function updateRecordAsync(record, recordFields) {
    if (table.hasPermissionToUpdateRecord(record, recordFields)) {
        await table.updateRecordAsync(record, recordFields);
    }
    // New record has been saved to Airtable servers.
    alert(`record with ID ${record.id} has been updated`);
}

// Fields can be specified by name or ID
updateRecord(record1, {
    'Post Title': 'How to make: orange-mango pound cake',
    'Publication Date': '2020-01-01',
});
updateRecord(record2, {
    [postTitleField.id]: 'Cake decorating tips & tricks',
    [publicationDateField.id]: '2020-02-02',
});
```

Returns **[Promise][70]&lt;RecordId>** A promise that will resolve to the RecordId of the new
record, once the new record is persisted to Airtable.

#### updateRecordsAsync

Updates cell values for records.

Throws an error if the user does not have permission to update the given cell values in the records,
or if invalid input is provided (eg. invalid cell values).

You may only update up to 50 records in one call to `updateRecordsAsync`. See [Writing changes to
records][107] for more information about write limits.

This action is asynchronous: `await` the returned promise if you wish to wait for the updates to be
persisted to Airtable servers. Updates are applied optimistically locally, so your changes will be
reflected in your block before the promise resolves.

##### Parameters

-   `records` **[Array][66]&lt;{id: RecordId, fields: [object][72]}>** Array of objects containing
    recordId and fields/cellValues to update for that record (specified as an object mapping
    `FieldId` or field name to cell value)

##### Examples

```javascript
const recordsToUpdate = [
    // Fields can be specified by name or ID
    {
        id: record1.id,
        fields: {
            'Post Title': 'How to make: orange-mango pound cake',
            'Publication Date': '2020-01-01',
        },
    },
    {
        id: record2.id,
        fields: {
            // Sets the cell values to be empty.
            'Post Title': '',
            'Publication Date': '',
        },
    },
    {
        id: record3.id,
        fields: {
            [postTitleField.id]: 'Cake decorating tips & tricks',
            [publicationDateField.id]: '2020-02-02',
        },
    },
];

function updateRecords() {
    if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
        table.updateRecordsAsync(recordsToUpdate);
    }
    // The records are now updated within your block (eg will be reflected in
    // `table.selectRecords()`) but are still being saved to Airtable servers (eg. they
    // may not be updated for other users yet)
}

async function updateRecordsAsync() {
    if (table.hasPermissionToUpdateRecords(recordsToUpdate)) {
        await table.updateRecordsAsync(recordsToUpdate);
    }
    // Record updates have been saved to Airtable servers.
    alert('records have been updated');
}
```

Returns **[Promise][70]&lt;void>** A promise that will resolve once the updates are persisted to
Airtable.

#### url

Type: [string][65]

##### Examples

```javascript
console.log(myTable.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx'
```

Returns **[string][65]** The URL for the table. You can visit this URL in the browser to be taken to
the table in the Airtable UI.

#### views

Type: [Array][66]&lt;[View][82]>

##### Examples

```javascript
console.log(`This table has ${myTable.views.length} views`);
```

Returns **[Array][66]&lt;[View][82]>** The views in this table. Can be watched to know when views
are created, deleted, or reordered.

#### watch

Get notified of changes to the table.

Watchable keys are:

-   `'name'`
-   `'views'`
-   `'fields'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableTableKey | [Array][66]&lt;WatchableTableKey>)** the keys to watch
-   `callback` **[Function][71]** a function to call when those keys change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableTableKey>** the array of keys that were watched

### View

**Extends AbstractModel**

A class that represents an Airtable view. Every [Table][19] has one or more views.

#### id

##### Examples

```javascript
console.log(myView.id);
// => 'viwxxxxxxxxxxxxxx'
```

Returns **[string][65]** This view's ID.

#### isDeleted

True if this view has been deleted.

In general, it's best to avoid keeping a reference to a view past the current event loop, since it
may be deleted and trying to access any data of a deleted view (other than its ID) will throw. But
if you do keep a reference, you can use `isDeleted` to check that it's safe to access the view's
data.

##### Examples

```javascript
if (!myView.isDeleted) {
    // Do things with myView
}
```

Returns **[boolean][69]** `true` if the view has been deleted, `false` otherwise.

#### name

Type: [string][65]

##### Examples

```javascript
console.log(myView.name);
// => 'Grid view'
```

Returns **[string][65]** The name of the view. Can be watched.

#### selectMetadata

Select the field order and visible fields from the view. See {@ViewMetadataQueryResult} for more.

##### Examples

```javascript
async function loadMetadataForViewAsync(view) {
    const viewMetadata = view.selectMetadata();
    await viewMetadata.loadDataAsync();

    console.log('Visible fields:');
    console.log(viewMetadata.visibleFields.map(field => field.name));
    // => ['Field 1', 'Field 2', 'Field 3']

    console.log('All fields:');
    console.log(viewMetadata.allFields.map(field => field.name));
    // => ['Field 1', 'Field 2', 'Field 3', 'Hidden field 4']

    viewMetadata.unloadData();
}
```

Returns **[ViewMetadataQueryResult][113]** a {@ViewMetadataQueryResult}

#### selectRecords

Select records from the view. Returns a query result. See {@RecordQueryResult} for more.

##### Parameters

-   `opts` **RecordQueryResultOpts** Options for the query, such as sorts, fields, and record
    coloring. By default, records will be coloured according to the view. (optional, default `{}`)

##### Examples

```javascript
import {UI} from '@airtable/blocks';
import React from 'react';

function TodoList() {
    const base = UI.useBase();
    const table = base.getTableByName('Tasks');
    const view = table.getViewByName('Grid view');

    const queryResult = view.selectRecords();
    const records = UI.useRecords(queryResult);

    return (
        <ul>
            {records.map(record => (
                <li key={record.id}>{record.primaryCellValueAsString || 'Unnamed record'}</li>
            ))}
        </ul>
    );
}
```

Returns **[TableOrViewQueryResult][112]** A record query result.

#### type

Type: ViewType

##### Examples

```javascript
console.log(myView.type);
// => 'kanban'
```

Returns **ViewType** The type of the view, such as Grid, Calendar, or Kanban. Should never change
because view types cannot be modified.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` the keys to unwatch
-   `callback` the function passed to `.watch` for these keys
-   `context` the context that was passed to `.watch` for this `callback`

Returns **any** the array of keys that were unwatched

#### url

Type: [string][65]

##### Examples

```javascript
console.log(myView.url);
// => 'https://airtable.com/tblxxxxxxxxxxxxxx/viwxxxxxxxxxxxxxx'
```

Returns **[string][65]** The URL for the view. You can visit this URL in the browser to be taken to
the view in the Airtable UI.

#### watch

Get notified of changes to the view.

Watchable keys are:

-   `'name'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` the keys to watch
-   `callback` a function to call when those keys change
-   `context` an optional context for `this` in `callback`.

Returns **any** the array of keys that were watched

### ViewMetadataQueryResult

**Extends AbstractModelWithAsyncData**

Contains information about a view that isn't loaded by default e.g. field order and visible fields.

In a React component, you might want to use [useViewMetadata][114].

#### Parameters

-   `baseData` **BaseData**
-   `parentView` **[View][82]**
-   `viewDataStore` **ViewDataStore**

#### Examples

```javascript
async function loadMetadataForViewAsync(view) {
    const viewMetadata = view.selectMetadata();
    await viewMetadata.loadDataAsync();

    console.log(viewMetadata.visibleField);
    // => [Field, Field, Field]

    console.log(viewMetadata.allFields);
    // => [Field, Field, Field, Field, Field]

    viewMetadata.unloadData();
}
```

#### allFields

Returns every field in the table in the order they appear in this view. Watchable.

Type: [Array][66]&lt;[Field][81]>

Returns **[Array][66]&lt;[Field][81]>**

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` the keys to unwatch
-   `callback` the function passed to `.watch` for these keys
-   `context` the context that was passed to `.watch` for this `callback`

Returns **any** the array of keys that were unwatched

#### visibleFields

Returns every field visible in this view. Watchable.

Type: [Array][66]&lt;[Field][81]>

Returns **[Array][66]&lt;[Field][81]>**

#### watch

Get notified of changes to the view meta data.

Watchable keys are:

-   `'visibleFields'`
-   `'allFields'`
-   `'isDataLoaded'`

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` the keys to watch
-   `callback` a function to call when those keys change
-   `context` an optional context for `this` in `callback`.

Returns **any** the array of keys that were watched

### Watchable

Abstract superclass for watchable models. All watchable models expose `watch` and `unwatch` methods
that allow consumers to subscribe to changes to that model.

This class should not be used directly.

#### unwatch

Unwatch keys watched with `.watch`.

Should be called with the same arguments given to `.watch`.

##### Parameters

-   `keys` **(WatchableKey | [Array][66]&lt;WatchableKey>)** the keys to unwatch
-   `callback` **function (model: this, key: WatchableKey): any** the function passed to `.watch`
    for these keys
-   `context` **[Object][72]??** the context that was passed to `.watch` for this `callback`

Returns **[Array][66]&lt;WatchableKey>** the array of keys that were unwatched

#### watch

Get notified of changes to the model.

Every call to `.watch` should have a matching call to `.unwatch`.

##### Parameters

-   `keys` **(WatchableKey | [Array][66]&lt;WatchableKey>)** the keys to watch
-   `callback` **function (model: this, key: WatchableKey): any** a function to call when those keys
    change
-   `context` **[Object][72]??** an optional context for `this` in `callback`.

Returns **[Array][66]&lt;WatchableKey>** the array of keys that were watched

## @airtable/blocks/ui

### initializeBlock

`initializeBlock` takes the top-level React component in your tree and renders it. It is
conceptually similar to `ReactDOM.render`, but takes care of some Blocks-specific things.

#### Parameters

-   `getEntryElement` **function (): React.Node** A function that returns your React Node.

#### Examples

```javascript
import {initializeBlock} from '@airtable/blocks/ui';
import React from 'react';

function App() {
    return <div>Hello world </div>;
}

initializeBlock(() => <App />);
```

### CSS & external scripts

#### loadCSSFromString

Injects CSS from a string into the page.

##### Parameters

-   `css` **[string][65]** {string}

##### Examples

```javascript
import {loadCSSFromString} from '@airtable/blocks/ui';
loadCSSFromString('body { background: red; }');
```

Returns **[HTMLStyleElement][115]** the style tag inserted into the page.

#### loadCSSFromURLAsync

Injects CSS from a remote URL.

##### Parameters

-   `url` **[string][65]** {string}

##### Examples

```javascript
import {loadCSSFromURLAsync} from '@airtable/blocks/ui';
loadCSSFromURLAsync('https://example.com/style.css');
```

Returns **[Promise][70]&lt;[HTMLLinkElement][116]>** a Promise that resolves to the style tag
inserted into the page.

#### loadScriptFromURLAsync

Injects Javascript from a remote URL.

##### Parameters

-   `url` **[string][65]** {string}

##### Examples

```javascript
import {loadScriptFromURLAsync} from '@airtable/blocks/ui';
loadScriptFromURLAsync('https://example.com/script.js');
```

Returns **[Promise][70]&lt;[HTMLScriptElement][117]>** a Promise that resolves to the script tag
inserted into the page.

### Color utilities

#### Color

A value from the [colors][118] enum

Type: \$Values&lt;any>

#### RGB

Type: {r: [number][73], g: [number][73], b: [number][73]}

##### Properties

-   `r` **[number][73]**
-   `g` **[number][73]**
-   `b` **[number][73]**

#### colorUtils

Utilities for working with [Color][98] names from the [colors][118] enum.

##### getHexForColor

Given a [Color][98], return the hex color value for that color, or null if the value isn't a
[Color][98]

###### Parameters

-   `colorString` {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.getHexForColor(colors.RED);
// => '#ef3061'

colorUtils.getHexForColor('uncomfortable beige');
// => null
```

Returns **([string][65] | null)**

##### getRgbForColor

Given a [Color][98], return an [RGB][119] object representing it, or null if the value isn't a
[Color][98]

###### Parameters

-   `colorString` {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.getRgbForColor(colors.PURPLE_DARK_1);
// => {r: 107, g: 28, b: 176}

colorUtils.getRgbForColor('disgruntled pink');
// => null
```

Returns **([RGB][120] | null)**

##### shouldUseLightTextOnColor

Given a [Color][98], returns true or false to indicate whether that color should have light text on
top of it when used as a background color.

###### Parameters

-   `colorString` **[string][65]** {Color}

###### Examples

```javascript
import {colorUtils, colors} from '@airtable/blocks/ui';

colorUtils.shouldUseLightTextOnColor(colors.PINK_LIGHT_1);
// => false

colorUtils.shouldUseLightTextOnColor(colors.PINK_DARK_1);
// => true
```

Returns **[boolean][69]** boolean

#### colors

An enum of color names

##### colors.BLUE

##### colors.BLUE_BRIGHT

##### colors.BLUE_DARK_1

##### colors.BLUE_LIGHT_1

##### colors.BLUE_LIGHT_2

##### colors.CYAN

##### colors.CYAN_BRIGHT

##### colors.CYAN_DARK_1

##### colors.CYAN_LIGHT_1

##### colors.CYAN_LIGHT_2

##### colors.GRAY

##### colors.GRAY_BRIGHT

##### colors.GRAY_DARK_1

##### colors.GRAY_LIGHT_1

##### colors.GRAY_LIGHT_2

##### colors.GREEN

##### colors.GREEN_BRIGHT

##### colors.GREEN_DARK_1

##### colors.GREEN_LIGHT_1

##### colors.GREEN_LIGHT_2

##### colors.ORANGE

##### colors.ORANGE_BRIGHT

##### colors.ORANGE_DARK_1

##### colors.ORANGE_LIGHT_1

##### colors.ORANGE_LIGHT_2

##### colors.PINK

##### colors.PINK_BRIGHT

##### colors.PINK_DARK_1

##### colors.PINK_LIGHT_1

##### colors.PINK_LIGHT_2

##### colors.PURPLE

##### colors.PURPLE_BRIGHT

##### colors.PURPLE_DARK_1

##### colors.PURPLE_LIGHT_1

##### colors.PURPLE_LIGHT_2

##### colors.RED

##### colors.RED_BRIGHT

##### colors.RED_DARK_1

##### colors.RED_LIGHT_1

##### colors.RED_LIGHT_2

##### colors.TEAL

##### colors.TEAL_BRIGHT

##### colors.TEAL_DARK_1

##### colors.TEAL_LIGHT_1

##### colors.TEAL_LIGHT_2

##### colors.YELLOW

##### colors.YELLOW_BRIGHT

##### colors.YELLOW_DARK_1

##### colors.YELLOW_LIGHT_1

##### colors.YELLOW_LIGHT_2

### React hooks for working with Airtable data

React hooks are a new feature in React 16.8. They allow you to use state and other React features
without writing a class, and form the core of how you can connect React components to data from your
Airtable base when writing Blocks. If you've never used hooks before, don't worry - the React team
[has some great resources][121] for learning about them. You can use hooks with class components too
with the help of the [withHooks][122] higher-order component.

> **Important Note:** right now, most of these hooks cause your component to re-render, but return
> the same mutable instance of the underlying model. This means that it's often not safe to use
> these hooks with React.memo or React.PureComponent. This will change in a future release of
> @airtable/blocks. If you're not sure what this means or if it effects you, don't worry! Just avoid
> React.memo & React.PureComponent and you'll be fine.

#### useBase

A hook for connecting a React component to your Base's schema. This returns a [Base][13] instance
and will re-render your component whenever the base's schema changes. That means any change to your
base like tables being added or removed, fields getting renamed, etc. It excludes any change to the
actual records in the base.

useBase should meet most of your needs for working with Base schema. If you need more granular
control of when your component updates or want to do anything other than re-render, the lower level
[useWatchable][123] hook might help.

##### Examples

```javascript
import {useBase} from '@airtable/blocks/ui';

// renders a list of tables and automatically updates
function TableList() {
    const base = useBase();

    const tables = base.tables.map(table => {
        return <li key={table.id}>{table.name}</li>;
    });

    return <ul>{tables}</ul>;
}
```

Returns **[Base][124]** Base

#### useGlobalConfig

Returns the [GlobalConfig][3] and updates whenever any key in GlobalConfig changes.

##### Examples

```javascript
import {useGlobalConfig} from '@airtable/blocks/ui';

function SyncedCounter() {
    const globalConfig = useGlobalConfig();
    const count = globalConfig.get('count');

    const increment = () => globalConfig.setAsync('count', count + 1);
    const decrement = () => globalConfig.setAsync('count', count - 1);
    const isEnabled = globalConfig.hasPermissionToSet('count');

    return (
        <React.Fragment>
            <button onClick={decrement} disabled={!isEnabled}>
                -
            </button>
            {count}
            <button onClick={increment} disabled={!isEnabled}>
                +
            </button>
        </React.Fragment>
    );
}
```

Returns **[GlobalConfig][125]** the [GlobalConfig][3]

#### useRecords

A hook for working with all the records (including their colors and cell values) in a particular
query result. Automatically handles loading data in the query result and updating your component
when the underlying data changes.

This hook re-renders when any data concerning the records changing - that's useful, but can cause
re-renders quite often, meaning [useRecordIds][94] or [useRecordById][95] could be more appropriate
depending on your use-case.

##### Parameters

-   `queryResult` **(QueryResult | null)** the query result you want the records from

##### Examples

```javascript
import {useRecords, useBase} from '@airtable/blocks';

function RecordList() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the records from that query result
    const records = useRecords(queryResult);

    // render a list of records:
    return (
        <ul>
            {records.map(record => {
                return <li key={record.id}>{record.primaryCellValueAsString}</li>;
            })}
        </ul>
    );
}
```

Returns **([Array][66]&lt;[Record][84]> | null)** the records in the query result, or null if no
query result was passed in.

#### useRecordIds

A hook for working with the set of record IDs in a particular query result. Automatically handles
loading data in the query result and updating your component when the underlying data changes.

This hook doesn't re-render when the data _inside_ the records changes - only when records are
added, removed, or re-ordered.

##### Parameters

-   `queryResult` **QueryResult** the query result you want the record ids from

##### Examples

```javascript
import {useRecordIds, useBase} from '@airtable/blocks/ui';

function RecordCount() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the record ids from that QueryResult
    const recordIds = useRecordIds(queryResult);

    // return the count
    return (
        <span>
            record count in {table.name}: {recordIds.length}
        </span>
    );
}
```

Returns **([Array][66]&lt;RecordId> | null)** the array of record IDs in the query result, or null
if no query result was passed in.

#### useRecordById

A hook for working with a single record from a query result. Automatically handles loading data in
the query result and updating your component when the records cell values etc. change.

Often used with [useRecordIds][94] to render a list of records where each list item only updates
when the specific record it concerns changes.

##### Parameters

-   `queryResult` **(QueryResult | null)** the query result you want a record from
-   `recordId` **RecordId** the ID of the record you want from the query result

##### Examples

```javascript
import {useRecordById, useRecordIds, useBase} from '@airtable/blocks';

// this component concerns a single record - it only updates when that specific record updates
function RecordListItem({queryResult, recordId}) {
    const record = useRecordById(queryResult, recordId);
    return <li>{record.primaryCellValueAsString}</li>;
}

// this component renders a list of records, but doesn't update when their cell values change -
// that's left up to RecordListItem
function RecordList() {
    // get a query result for the records in the first table
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();

    // grab all the record ids from that query result
    const recordIds = useRecordIds(queryResult);

    // render a list of records:
    return (
        <ul>
            {recordsIds.map(recordId => {
                return (
                    <RecordListItem key={recordId} recordId={recordId} queryResult={queryResult} />
                );
            })}
        </ul>
    );
}
```

Returns **([Record][84] | null)** the record, or null if no query result was passed in or no record
with that ID exists in the query result

#### useSession

A hook for connecting a React component to the current [Session][14]. This returns a [Session][14]
instance and will re-render your component whenever the session changes (e.g. when the current
user's permissions change or when the current user's name changes).

useSession should meet most of your needs for working with Session. If you need more granular
control of when your component updates or want to do anything other than re-render, the lower level
[useWatchable][123] hook might help.

##### Examples

```javascript
import {CollaboratorToken, useSession} from '@airtable/blocks/ui';

// Says hello to the current user and updates in realtime if the current user's
// name or profile pic changes.
function CurrentUserGreeter() {
    const session = useSession();
    return (
        <React.Fragment>
            Hello,
            <CollaboratorToken collaborator={session.currentUser} />!
        </React.Fragment>
    );
}
```

Returns **[Session][126]** Session

#### useSettingsButton

A hook for using the settings button that lives outside the block's viewport. It will show the
settings button (hidden by default) and call the provided callback whenever the settings button is
clicked. It will also re-render your component when the settings button is clicked.

##### Parameters

-   `onClickCallback` **[Function][71]** a callback to call when the button is clicked

##### Examples

```javascript
import {useSettingsButton} from '@airtable/blocks/ui';
import {useState} from 'react';

function ComponentWithSettings() {
    const [isShowingSettings, setIsShowingSettings] = useState(false);
    useSettingsButton(function() {
        setIsShowingSettings(!isShowingSettings);
    });

    if (isShowingSettings) {
        return <SettingsComponent />;
    }
    return <MainComponent />;
}
```

#### useViewport

Returns the current [Viewport][5] object and updates whenever the viewport size, constraints, or
fullscreen status changes.

##### Examples

```javascript
import {useViewport} from '@airtable/blocks/ui';

function ViewportSize() {
    const viewport = useViewport();

    const toggleFullscreen = () => {
        if (viewport.isFullscreen) {
            viewport.exitFullscreen();
        } else {
            viewport.enterFullscreenIfPossible();
        }
    };

    return (
        <Fragment>
            <button onClick={toggleFullscreen}>Toggle fullscreen</button>
            viewport size: {viewport.size.width}x{viewport.size.height}
        </Fragment>
    );
}
```

Returns **[Viewport][127]** the current [Viewport][5]

#### useViewMetadata

Returns a [ViewMetadataQueryResult][21] for the specified view and re-renders whenever the view meta
data changes. Suspends if the view is not already loaded.

##### Parameters

-   `viewOrViewMetadataQueryResult` **any**

##### Examples

```javascript
import {useBase, useViewMetadata} from '@airtable/blocks/ui';

function ViewFields({view}) {
    const viewMetadata = useViewMetadata(view);

    return (
        <ul>
            {viewMetadata.visibleFields.map(field => (
                <li key={field.id}>{field.name}</li>
            ))}
        </ul>
    );
}
```

#### useWatchable

A React hook for watching data in Airtable models like [Table][19] and [Record][18]. Each model has
several watchable keys that can be used with this hook to have your component automatically
re-render when data in the models changes. You can also provide an optional callback if you need to
do anything other than re-render when the data changes.

This is a low-level tool that you should only use when you specifically need it. There are more
convenient model-specific hooks available:

-   For [Base][13], [Table][19], [View][20] & [Field][16], use [useBase][62]
-   For [RecordQueryResult][17] & [Record][18], use [useRecords][93], [useRecordIds][94], or
    [useRecordById][95]
-   For [Viewport][5], use [useViewport][128].

If you're writing a class component and still want to be able to use hooks, try [withHooks][122].

##### Parameters

-   `model` **[Watchable][129]?** the model to watch
-   `keys` **[Array][66]&lt;[string][65]?>** which keys we want to watch
-   `callback` **function (): any?** an optional callback to call when any of the watch keys change

##### Examples

```javascript
import {useWatchable} from '@airtable/blocks/ui';

function TableName({table}) {
    useWatchable(table, ['name']);
    return <span>The table name is {table.name}</span>;
}
```

```javascript
import {useWatchable} from '@airtable/blocks/ui';

function ActiveView({cursor}) {
    useWatchable(cursor, ['activeViewId'], () => {
        alert('active view changed!!!');
    });

    return <span>Active view id: {cursor.activeViewId}</span>;
}
```

#### useLoadable

When you're writing a block, not all of the data in your base is available to work with straight
away. We need to load it from Airtable first. This hook is a low-level tool for managing that. You
might not need to use it directly though - if you're working with a [RecordQueryResult][17], try
[useRecords][93], [useRecordIds][94], or [useRecordById][95] first.

When you need to use a loadable model, `useLoadable(theModel)` will make sure that the model is
loaded when your component mounts, and unloaded when your component unmounts. By default, you don't
need to worry about waiting for the data to load - the hook uses React Suspense to make sure the
rest of your component doesn't run until the data is loaded. Whilst the data is loading, the entire
block will show a loading indicator. If you want to change where that indicator shows or how it
looks, use [&lt;React.Suspense />][130] around the component that uses the hook.

You can pass several models to `useLoadable` in an array - it will load all of them simultaneously.
We'll memoize this array using shallow equality, so there's no need to use `useMemo`.

If you need more control, you can pass `{shouldSuspend: false}` as a second argument to the hook. In
that case though, `useLoadable` will cause your component to re-render whenever the load-state of
any model you passed in changes, and you should check each model's `.isDataLoaded` property before
trying to use the data you loaded.

##### Parameters

-   `models` **(QueryResult | [Cursor][131] \| [Array][66]&lt;(QueryResult | [Cursor][131] | null)>
    | null)** the models to load.
-   `options` **[object][72]?** Optional options to control how the hook works (optional, default
    `{}`)
    -   `options.shouldSuspend` **[boolean][69]** pass {shouldSuspend: false} to disable suspense
        mode. If suspense is disabled, you need to manually check model.isDataLoaded so you don't
        use your model before it's ready. (optional, default `true`)

##### Examples

```javascript
import {cursor} from '@airtable/blocks';
import {useLoadable, useWatchable} from '@airtable/blocks/ui';

function SelectedRecordIds() {
    // load selected records
    useLoadable(cursor);

    // re-render whenever the list of selected records changes
    useWatchable(cursor, ['selectedRecordIds']);

    // render the list of selected record ids
    return <div>Selected records: {cursor.selectedRecordIds.join(', ')}</div>;
}
```

```javascript
import {useLoadable} from '@airtable/blocks/ui';

function LoadTwoQueryResults({queryResultA, queryResultB}) {
    // load the queryResults:
    useLoadable([queryResultA, queryResultB]);

    // now, we can use the data
    return <SomeFancyComponent />;
}
```

```javascript
import {useLoadable, useBase} from '@airtable/blocks/ui';

function LoadAllRecords() {
    const base = useBase();

    // get a query result for every table in the base:
    const queryResults = base.tables.map(table => table.selectRecords());

    // load them all:
    useLoadable(queryResults);

    // use the data:
    return <SomeFancyComponent queryResults={queryResults} />;
}
```

#### withHooks

A helper method for working with react hooks in class-based components. It takes a React component
and wraps it, injecting values from hooks as additional props. `withHooks` uses
[React.forwardRef][132] to make sure that you can use refs with your wrapped component in exactly
the same way you would if you weren't using withHooks.

##### Parameters

-   `Component` **React.Component** The React component you want to inject hooks into
-   `getAdditionalPropsToInject` **[Function][71]** a function that takes props and returns more
    props to be injected into the wrapped component

##### Examples

```javascript
import React from 'react';
import {useRecords, withHooks} from '@airtable/blocks/ui';

// RecordList takes a list of records and renders it
class RecordList extends React.Component {
    render() {
        const records = this.props.records.map(record => {
            return <li key={record.id}>{record.primaryCellValueAsString}</li>;
        });

        return <ul>{records}</ul>;
    }
}

// using withHooks, we wrap up RecordList. It takes a queryResult prop, and injects a records
// prop from useRecords
const WrappedRecordList = withHooks(RecordList, ({queryResult}) => {
    const records = useRecords(queryResult);
    return {
        records: records,
    };
});

// when we use WrappedRecordList, we only need to pass in queryResult:
<WrappedRecordList queryResult={someQueryResult} />;
```

```javascript
import React from 'react';
import {Record, QueryResult} from '@airtable/blocks/models';
import {withHooks, useRecords} from '@airtable/blocks/ui';
// with flow, things are a little more complex: we need to provide some type annotations to
// indicate which props are injected:

type RequiredProps = {|
    queryResult: QueryResult,
|};

type InjectedProps = {|
    records: Array<Record>,
|};

type RecordListProps = {|
    ...RequiredProps,
    ...InjectedProps,
|};

class RecordList extends React.Component<RecordListProps> {
    // implementation is the same as the example above
}

// you need to annotate the return type as React.AbstractComponent. This takes two type args:
//   - the Config (usually just props) of the resulting component
//   - the instance type (what you get out of a ref) of the resulting component
const WrappedRecordList: React.AbstractComponent<RequiredProps, RecordList> = withHooks(
    RecordList,
    ({queryResult}) => {
        const records = useRecords(queryResult);
        return {
            records,
        };
    },
);

// when using a ref to the component, you can't refer to it as WrappedRecordList like a normal
// class component. Instead, you need to wrap it in React.ElementRef:
const ref: React.ElementRef<typeof WrappedRecordList> = getTheRefSomehow();
```

Returns **React.Component** the wrapped React component

### expandRecord

#### expandRecord

Expands the given record in the Airtable UI.

##### Parameters

-   `record` **[Record][84]** the record to expand
-   `opts` **[object][72]?** An optional options object.
    -   `opts.records` **[Array][66]&lt;[Record][84]>?** If `records` is provided, the list will be
        used to page through records from the expanded record dialog.

##### Examples

```javascript
import {expandRecord} from '@airtable/blocks/ui';
expandRecord(record1, {
    records: [record1, record2, record3],
});
```

#### ExpandRecordOpts

Type: {records: [Array][66]&lt;[Record][84]>?}

##### Properties

-   `records` **[Array][66]&lt;[Record][84]>?**

### expandRecordList

Expands a list of records in the Airtable UI

#### Parameters

-   `records` **[Array][66]&lt;[Record][84]>** the records to expand. Duplicate records will be
    removed.
-   `opts` **{fields: [Array][66]&lt;[Field][81]>?}?** An optional options object.
    -   `opts.fields` optionally include an array of fields to control which fields are shown in the
        record cards. The primary field will always be shown. Duplicate fields will be removed.

#### Examples

```javascript
import {expandRecordList} from '@airtable/blocks/ui';
expandRecordList([record1, record2, record3]);

expandRecordList([record1, record2], {
    fields: [field1, field2],
});
```

### expandRecordPickerAsync

Expands a list of records in the Airtable UI, and prompts the user to pick one. The selected record
is returned to the block, and the modal is automatically closed.

If the user dismisses the modal, or another one is opened before this one has been closed, it will
return null.

#### Parameters

-   `records` **[Array][66]&lt;[Record][84]>** the records the user can pick from. Duplicate records
    will be removed.
-   `opts` **{fields: [Array][66]&lt;[Field][81]>?, shouldAllowCreatingRecord: [boolean][69]?}?** An
    optional options object.
    -   `opts.fields` optionally include an array of fields to control which fields are shown in the
        record cards. The primary field will always be shown. Duplicate fields will be removed.
    -   `opts.shouldAllowCreatingRecord` set to true to allow the user to create an empty new
        record.

#### Examples

```javascript
import {expandRecordPickerAsync} from '@airtable/blocks/ui';

async function pickRecordsAsync() {
    const recordA = await expandRecordPickerAsync([record1, record2, record3]);
    if (recordA !== null) {
        alert(recordA.primaryCellValueAsString);
    } else {
        alert('no record picked');
    }

    const recordB = await expandRecordPickerAsync([record1, record2], {
        fields: [field1, field2],
    });
}
```

Returns **[Promise][70]&lt;(record | null)>** a Promise that resolves to the record chosen by the
user or null

### Button

#### Button

**Extends React.Component**

Clickable button component.

##### Parameters

-   `props` **[ButtonProps][133]**

##### Examples

```javascript
import {Button} from '@airtable/blocks/ui';

const button = (
    <Button onClick={() => alert('Clicked!')} disabled={false} theme={Button.themes.BLUE}>
        Click here!
    </Button>
);
```

#### ButtonProps

Type: [object][72]

##### Properties

-   `theme` **(Button.themes.RED | Button.themes.GREEN | Button.themes.BLUE | Button.themes.YELLOW |
    Button.themes.WHITE | Button.themes.GRAY | Button.themes.DARK | Button.themes.TRANSPARENT)?**
    The color theme for the button.
-   `className` **[string][65]?** Extra `className`s to apply to the button, separated by spaces.
-   `style` **[object][72]?** Extra styles to apply to the button.
-   `onClick` **[function][71]?** Click event handler. Also handles Space and Enter keypress events.
-   `type` **[string][65]?** The type of the button.
-   `disabled` **[boolean][69]?** Indicates whether or not the user can interact with the button.
-   `tabIndex` **([number][73] \| [string][65])?** Indicates if the button can be focused and
    if/where it participates in sequential keyboard navigation.
-   `aria-label` **[string][65]?** The label for the button. Use this if the button lacks a visible
    text label.

### CellRenderer

#### CellRenderer

**Extends React.Component**

Displays the contents of a cell.

##### Parameters

-   `props` **[CellRendererProps][134]**

##### Examples

```javascript
import React, {useState} from 'react';
import {Box, CellRenderer, FieldPicker, useBase, useRecords} from '@airtable/blocks/ui';

export default function CellRendererExample(props: void) {
    const [field, setField] = useState(null);
    const base = useBase();
    const table = base.tables[0];
    const queryResult = table.selectRecords();
    const records = useRecords(queryResult);
    return (
        <Box display="flex" flexDirection="column">
            <FieldPicker table={table} field={field} onChange={setField} />
            {field && (
                <CellRenderer
                    className="user-defined-class"
                    field={field}
                    record={records[0]}
                    margin={3}
                />
            )}
        </Box>
    );
}
```

#### CellRendererProps

Type: [object][72]

##### Properties

-   `record` **[Record][84]?** The [Record][18] from which to render a cell. Either `record` or
    `cellValue` must be provided to the CellRenderer. If both are provided, `record` will be used.
-   `cellValue` **([string][65] \| [number][73] \| [Object][72] \| [Array][66]&lt;[Object][72]>)?**
    The cell value to render. Either `record` or `cellValue` must be provided to the CellRenderer.
    If both are provided, `record` will be used.
-   `field` **[Field][81]** The [Field][16] for a given [Record][18] being rendered as a cell.
-   `shouldWrap` **[boolean][69]?** Whether to wrap cell contents. Defaults to true.
-   `className` **[string][65]?** Additional class names to apply to the cell renderer container,
    separated by spaces.
-   `style` **[object][72]?** Additional styles to apply to the cell renderer container.
-   `cellClassName` **[string][65]?** Additional class names to apply to the cell itself, separated
    by spaces.
-   `cellStyle` **[object][72]?** Additional styles to apply to the cell itself.

### ChoiceToken

#### ChoiceToken

**Extends React.StatelessFunctionalComponent**

A component that shows a single choice in a small token, to be displayed inline or in a list of
choices.

##### Parameters

-   `props` **[ChoiceTokenProps][135]**

##### Examples

```javascript
import {UI} from '@airtable/blocks';

function ChoicesForSelectField({selectField}) {
    const choiceNodes = selectField.options.choices.map(choice => (
        <UI.ChoiceToken key={choice.id} choice={choice} />
    ));

    return (
        <React.Fragment>
            Here are all of your choices:
            {choiceNodes}
        </React.Fragment>
    );
}
```

#### ChoiceTokenProps

Type: [object][72]

##### Properties

-   `choice` **[object][72]** An object representing a select option. You should not create these
    objects from scratch, but should instead grab them from base data.
    -   `choice.id` **[string][65]** The ID of the select option.
    -   `choice.name` **[string][65]** The name of the select option.
    -   `choice.color` **[string][65]?** The color of the select option.
-   `style` **[string][65]?** Additional styles to apply to the choice token.
-   `className` **[string][65]?** Additional class names to apply to the choice token.

### CollaboratorToken

#### CollaboratorToken

**Extends React.StatelessFunctionalComponent**

A component that shows a single collaborator in a small token, to be displayed inline or in a list
of choices.

##### Parameters

-   `props` **[CollaboratorTokenProps][136]**

##### Examples

```javascript
import {CollaboratorToken, useSession} from '@airtable/blocks/ui';

function CurrentUserGreeter() {
    const session = useSession();
    return (
        <React.Fragment>
            Hello,
            <CollaboratorToken collaborator={session.currentUser} />!
        </React.Fragment>
    );
}
```

#### CollaboratorTokenProps

Type: [object][72]

##### Properties

-   `collaborator` **[object][72]** An object representing a collaborator. You should not create
    these objects from scratch, but should instead grab them from base data.
    -   `collaborator.id` **[string][65]?** The user ID of the collaborator.
    -   `collaborator.email` **[string][65]?** The email address of the collaborator.
    -   `collaborator.name` **[string][65]?** The name of the collaborator.
    -   `collaborator.status` **[string][65]?** The status of the collaborator.
    -   `collaborator.profilePicUrl` **[string][65]?** The URL of the collaborator's profile
        picture.
-   `className` **[string][65]?** Additional class names to apply to the collaborator token.
-   `style` **[string][65]?** Additional styles to apply to the collaborator token.

### ColorPalette

#### ColorPalette

**Extends React.Component**

A color selection component. Accepts a list of `allowedColors` to be displayed as selectable color
squares.

##### Parameters

-   `props` **[ColorPaletteProps][137]**

##### Examples

```javascript
import {ColorPalette, colors} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function DisplayOptions() {
    const allowedColors = [colors.GREEN, colors.BLUE, colors.RED];
    const [selectedColor, setSelectedColor] = useState(colors.GREEN);
    return <ColorPalette allowedColors={allowedColors} onChange={setSelectedColor} />;
}
```

#### ColorPaletteProps

Type: [object][72]

##### Properties

-   `color` **[string][65]?** The current selected [Color][98] option.
-   `allowedColors` **[Array][66]&lt;[string][65]>** The list of [colors][118] to display in the
    color palette.
-   `onChange` **[function][71]?** A function to be called when the selected color changes.
-   `squareMargin` **[number][73]?** The margin between color squares in the color palette.
-   `className` **[string][65]?** Additional class names to apply to the color palette, separated by
    spaces.
-   `style` **[object][72]?** Additional styles to apply to the color palette.
-   `disabled` **[boolean][69]?** If set to `true`, the color palette will not allow color
    selection.

### ColorPaletteSynced

#### ColorPaletteSynced

**Extends React.Component**

A wrapper around the [ColorPalette][35] component that syncs with global config.

##### Examples

```javascript
import {ColorPaletteSynced, colors} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React from 'react';

function DisplayOptions() {
    const allowedColors = [colors.GREEN, colors.BLUE, colors.RED];
    return <ColorPaletteSynced allowedColors={allowedColors} globalConfigKey="displayColor" />;
}
```

#### ColorPaletteSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** The key, or path to a key, in global config.
-   `allowedColors` **[Array][66]&lt;[string][65]>** The list of [colors][118] to display in the
    color palette.
-   `squareMargin` **[number][73]?** The margin between color squares in the color palette.
-   `className` **[string][65]?** Additional class names to apply to the color palette, separated by
    spaces.
-   `style` **[object][72]?** Additional styles to apply to the color palette.
-   `disabled` **[boolean][69]?** If set to `true`, the color palette will not allow color
    selection.
-   `onChange` **[function][71]?** A function to be called when the selected color changes.

### ConfirmationDialog

#### ConfirmationDialog

**Extends React.Component**

A styled modal dialog component that prompts the user to confirm or cancel an action. By default,
this component will focus the "Confirm" button on mount, so that pressing the Enter key will confirm
the action.

##### Parameters

-   `props` **[ConfirmationDialogProps][139]**

##### Examples

```javascript
import {Button, Dialog, ConfirmationDialog} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    return (
        <Fragment>
            <Button theme={Button.themes.BLUE} onClick={() => setIsDialogOpen(true)}>
                Open dialog
            </Button>
            {isDialogOpen && (
                <ConfirmationDialog
                    title="Are you sure?"
                    body="This action can't be undone."
                    onConfirm={() => {
                        alert('Confirmed.');
                        setIsDialogOpen(false);
                    }}
                    onCancel={() => setIsDialogOpen(false)}
                />
            )}
        </Fragment>
    );
}
```

#### ConfirmationDialogProps

Type: [Object][72]

##### Properties

-   `title` **[string][65]** The title of the dialog.
-   `body` **React.Node?** The body of the dialog.
-   `cancelButtonText` **[string][65]?** The label for the cancel button.
-   `confirmButtonText` **[string][65]?** The label for the confirm button.
-   `isConfirmActionDangerous` **[boolean][69]?** Whether the action is dangerous (potentially
    destructive or not easily reversible).
-   `className` **[string][65]?** Extra `className`s to apply to the dialog element, separated by
    spaces.
-   `style` **[Object][72]?** Extra styles to apply to the dialog element.
-   `backgroundClassName` **[string][65]?** Extra `className`s to apply to the background element,
    separated by spaces.
-   `backgroundStyle` **[Object][72]?** Extra styles to apply to the background element.
-   `onCancel` **[function][71]** Cancel button event handler. Handles click events and Space/Enter
    keypress events.
-   `onConfirm` **[function][71]** Confirm button event handler. Handles click events and
    Space/Enter keypress events.

### Dialog

#### Dialog

**Extends React.Component**

A styled modal dialog component.

##### Parameters

-   `props` **[DialogProps][140]**

##### Examples

```javascript
import {Button, Dialog} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    const [isDialogOpen, setIsDialogOpen] = useState(false);
    return (
        <Fragment>
            <Button theme={Button.themes.BLUE} onClick={() => setIsDialogOpen(true)}>
                Open dialog
            </Button>
            {isDialogOpen && (
                <Dialog onClose={() => setIsDialogOpen(false)}>
                    <Fragment>
                        <Dialog.CloseButton />
                        <h1
                            style={{
                                marginBottom: 8,
                                fontSize: 20,
                                fontWeight: 500,
                            }}
                        >
                            Dialog
                        </h1>
                        <p>This is the dialog content.</p>
                    </Fragment>
                </Dialog>
            )}
        </Fragment>
    );
}
```

#### DialogProps

Type: [object][72]

##### Properties

-   `onClose` **[function][71]** Callback function to fire when the dialog is closed.
-   `className` **[string][65]?** Extra `className`s to apply to the dialog element, separated by
    spaces.
-   `style` **[Object][72]?** Extra styles to apply to the dialog element.
-   `backgroundClassName` **[string][65]?** Extra `className`s to apply to the background element,
    separated by spaces.
-   `backgroundStyle` **[Object][72]?** Extra styles to apply to the background element.

#### Dialog.CloseButton

**Extends React.Component**

A button that closes [Dialog][38].

##### Parameters

-   `props` **[DialogCloseButtonProps][141]**

#### DialogCloseButtonProps

Type: [object][72]

##### Properties

-   `className` **[string][65]?** `className`s to apply to the close button, separated by spaces.
-   `style` **[object][72]?** Styles to apply to the dialog element.
-   `tabIndex` **([number][73] \| [string][65])?** Indicates if the button can be focused and
    if/where it participates in sequential keyboard navigation.

### FieldPicker

#### FieldPicker

**Extends React.Component**

Dropdown menu component for selecting fields.

##### Parameters

-   `props` **[FieldPickerProps][142]**

##### Examples

```javascript
import {TablePicker, FieldPicker, useBase} from '@airtable/blocks/ui';
import {fieldTypes} from '@airtable/blocks/models';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const [field, setField] = useState(null);

    const summaryText = field
        ? `The field type for ${field.name} is ${field.type}.`
        : 'No field selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => {
                        setTable(newTable);
                        setField(null);
                    }}
                    shouldAllowPickingNone={true}
                />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>Field</div>
                    <FieldPicker
                        table={table}
                        field={field}
                        onChange={newField => setField(newField)}
                        allowedTypes={[
                            fieldTypes.SINGLE_LINE_TEXT,
                            fieldTypes.MULTILINE_TEXT,
                            fieldTypes.EMAIL,
                            fieldTypes.URL,
                            fieldTypes.PHONE_NUMBER,
                        ]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### FieldPickerProps

Type: [object][72]

##### Properties

-   `field` **[Field][81]?** The selected field model.
-   `table` **[Table][86]?** The parent table model to select fields from. If `null` or `undefined`,
    the picker won't render.
-   `allowedTypes` **[Array][66]&lt;FieldType>?** An array indicating which field types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    field.
-   `placeholder` **[string][65]?** The placeholder text when no field is selected.
-   `onChange` **[function][71]?** A function to be called when the selected field changes.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### FieldPickerSynced

#### FieldPickerSynced

**Extends React.Component**

Dropdown menu component for selecting fields, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[FieldPickerSyncedProps][143]**

##### Examples

```javascript
import {TablePickerSynced, FieldPickerSynced, useBase, useWatchable} from '@airtable/blocks/ui';
import {fieldTypes} from '@airtable/blocks/models';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const fieldId = globalConfig.get('fieldId');
    const field = table.getFieldByIdIfExists(fieldId);
    useWatchable(globalConfig, ['tableId', 'fieldId']);

    const summaryText = field
        ? `The field type for ${field.name} is ${field.type}.`
        : 'No field selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>Field</div>
                    <FieldPickerSynced
                        table={table}
                        globalConfigKey="fieldId"
                        allowedTypes={[
                            fieldTypes.SINGLE_LINE_TEXT,
                            fieldTypes.MULTILINE_TEXT,
                            fieldTypes.EMAIL,
                            fieldTypes.URL,
                            fieldTypes.PHONE_NUMBER,
                        ]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### FieldPickerSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The selected field will always reflect the field id stored in `globalConfig`
    for this key. Selecting a new field will update `globalConfig`.
-   `table` **[Table][86]?** The parent table model to select fields from. If `null` or `undefined`,
    the picker won't render.
-   `allowedTypes` **[Array][66]&lt;FieldType>?** An array indicating which field types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    field.
-   `placeholder` **[string][65]?** The placeholder text when no field is selected.
-   `onChange` **[function][71]?** A function to be called when the selected field changes. This
    should only be used for side effects.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### Icon

#### Icon

**Extends React.StatelessFunctionalComponent**

A vector icon from the Airtable icon set.

##### Parameters

-   `props` **[IconProps][144]**

##### Examples

```javascript
import {Button, Icon} from '@airtable/blocks/ui';

const LikeButton = (
    <Button theme={Button.themes.RED} onClick={() => alert('Liked!')}>
        <Icon name="heart" fillColor="#fff" style={{marginRight: 8}} />
        Like
    </Button>
);
```

#### IconProps

Type: [object][72]

##### Properties

-   `name` **[string][65]** The name of the icon. For more details, see the [list of supported
    icons][145].
-   `size` **[number][73]?** The width/height of the icon.
-   `fillColor` **[string][65]?** The color of the icon.
-   `className` **[string][65]?** Additional class names to apply to the icon.
-   `style` **[object][72]?** Additional styles to apply to the icon.
-   `pathClassName` **[string][65]?** Additional class names to apply to the icon path.
-   `pathStyle` **[object][72]?** Additional styles to apply to the icon path.

#### FieldIcon

**Extends React.StatelessFunctionalComponent**

A vector icon for a field's type.

##### Parameters

-   `props` **[FieldIconProps][146]**

##### Examples

```javascript
import {FieldIcon, useBase} from '@airtable/blocks/ui';

const base = useBase();
const table = base.tables[0];
const {primaryField} = table;

const FieldToken = (
    <div
        style={{
            display: 'inline-flex',
            alignItems: 'center',
            padding: 8,
            fontWeight: 500,
            backgroundColor: '#eee',
            borderRadius: 3,
        }}
    >
        <FieldIcon field={primaryField} marginRight={2} />
        {primaryField.name}
    </div>
);
```

#### FieldIconProps

Type: [object][72]

##### Properties

-   `field` **[Field][81]** The field model to display an icon for.
-   `size` **[number][73]?** The width/height of the icon.
-   `fillColor` **[string][65]?** The color of the icon.
-   `className` **[string][65]?** Additional class names to apply to the icon.
-   `style` **[object][72]?** Additional styles to apply to the icon.
-   `pathClassName` **[string][65]?** Additional class names to apply to the icon path.
-   `pathStyle` **[object][72]?** Additional styles to apply to the icon path.

### Input

#### Input

**Extends React.Component**

An input component. A wrapper around `<input>` that fits in with Airtable's user interface.

##### Parameters

-   `props` **[InputProps][147]**

##### Examples

```javascript
import {Input} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function HelloSomeone() {
    const [value, setValue] = useState('world');

    return (
        <Fragment>
            <div>Hello, {value}!</div>

            <Input
                value={value}
                onChange={event => setValue(event.target.value)}
                placeholder="world"
            />
        </Fragment>
    );
}
```

#### InputProps

Type: [object][72]

##### Properties

-   `value` **[string][65]** The input's current value.
-   `onChange` **[function][71]** A function to be called when the input changes.
-   `type` **[string][65]?** The `type` for the input. Defaults to `text`.
-   `placeholder` **[string][65]?** The placeholder for the input.
-   `style` **[object][72]?** Additional styles to apply to the input.
-   `className` **[string][65]?** Additional class names to apply to the input, separated by spaces.
-   `disabled` **[boolean][69]?** The `disabled` attribute.
-   `required` **[boolean][69]?** The `required` attribute.
-   `spellCheck` **[boolean][69]?** The `spellcheck` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `id` **[string][65]?** The `id` attribute.
-   `autoFocus` **[boolean][69]?** The `autoFocus` attribute.
-   `max` **([number][73] \| [string][65])?** The `max` attribute.
-   `maxLength` **[number][73]?** The `maxLength` attribute.
-   `min` **([number][73] \| [string][65])?** The `min` attribute.
-   `minLength` **[number][73]?** The `minLength` attribute.
-   `step` **([number][73] \| [string][65])?** The `step` attribute.
-   `pattern` **[string][65]?** The `pattern` attribute.
-   `readOnly` **[boolean][69]?** The `readOnly` attribute.
-   `autoComplete` **[string][65]?** The `autoComplete` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### InputSynced

#### InputSynced

**Extends React.Component**

A wrapper around the `UI.Input` component that syncs with global config.

##### Parameters

-   `props` **[InputSyncedProps][148]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React from 'react';

function ApiKeyInput() {
    return <UI.InputSynced globalConfigKey="apiKey" disabled={!canEditApiKey} />;
}
```

#### InputSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **([string][65] \| [Array][66]&lt;[string][65]>)** The key, or path to a key,
    in global config.
-   `onChange` **[function][71]** A function to be called when the input changes.
-   `type` **[string][65]?** The `type` for the input. Defaults to `text`.
-   `placeholder` **[string][65]?** The placeholder for the input.
-   `style` **[object][72]?** Additional styles to apply to the input.
-   `className` **[string][65]?** Additional class names to apply to the input, separated by spaces.
-   `disabled` **[boolean][69]?** The `disabled` attribute.
-   `required` **[boolean][69]?** The `required` attribute.
-   `spellCheck` **[boolean][69]?** The `spellcheck` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `id` **[string][65]?** The `id` attribute.
-   `autoFocus` **[boolean][69]?** The `autoFocus` attribute.
-   `max` **([number][73] \| [string][65])?** The `max` attribute.
-   `maxLength` **[number][73]?** The `maxLength` attribute.
-   `min` **([number][73] \| [string][65])?** The `min` attribute.
-   `minLength` **[number][73]?** The `minLength` attribute.
-   `step` **([number][73] \| [string][65])?** The `step` attribute.
-   `pattern` **[string][65]?** The `pattern` attribute.
-   `readOnly` **[boolean][69]?** The `readOnly` attribute.
-   `autoComplete` **[string][65]?** The `autoComplete` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### Link

#### Link

**Extends React.StatelessFunctionalComponent**

A wrapper around the `<a>` tag that offers a few security benefits:

-   Limited XSS protection. If the `href` starts with `javascript:` or `data:`, `http://` will be
    prepended.
-   There is [reverse tabnabbing prevention][149]. If `target` is set, the `rel` attribute will be
    set to `noopener noreferrer`.

Developers should use `Link` instead of `a` when possible.

##### Parameters

-   `props` **[LinkProps][150]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';

function MyLinkComponent() {
    return <UI.Link href="https://example.com">Check out my homepage!</UI.Link>;
}
```

#### LinkProps

Type: [object][72]

##### Properties

-   `href` **[string][65]** The target URL or URL fragment for the link.
-   `target` **[string][65]?** Specifies where to display the linked URL.
-   `tabIndex` **([number][73] \| [string][65])?** Indicates if the link can be focused and if/where
    it participates in sequential keyboard navigation.
-   `className` **[string][65]?** Additional class names to apply to the link.
-   `style` **[object][72]?** Additional styles to apply to the link.

### Loader

#### Loader

**Extends React.StatelessFunctionalComponent**

A loading spinner component.

##### Parameters

-   `props` **[LoaderProps][151]**

##### Examples

```javascript
import {Loader} from '@airtable/blocks/ui';

function MyDataComponent() {
    if (myDataHasLoaded) {
        return <div>Here's your data!</div>;
    } else {
        return <Loader />;
    }
}
```

#### LoaderProps

Type: [object][72]

##### Properties

-   `fillColor` **[string][65]?** The color of the loading spinner.
-   `scale` **[number][73]?** A scalar for the loading spinner. Increasing the scale increases the
    size of the loading spinner.
-   `className` **[string][65]?** Additional class names to apply to the loading spinner.
-   `style` **[object][72]?** Additional styles to apply to the loading spinner.

### Popover

#### Popover

**Extends React.Component**

-   **See: [Tooltip][58]**

A popover component, which is used to "float" some content above some other content.

##### Parameters

-   `props` **[PopoverProps][152]**

#### PopoverProps

Type: [object][72]

##### Properties

-   `children` **React\$Element&lt;any>** Child components to render.
-   `renderContent` **[function][71]** A function that returns the contents of the popover as React
    elements.
-   `placementX` **(Popover.placements.LEFT | Popover.placements.CENTER |
    Popover.placements.RIGHT)?** The horizontal placement of the popover.
-   `placementY` **(Popover.placements.TOP | Popover.placements.CENTER |
    Popover.placements.BOTTOM)?** The vertical placement of the popover.
-   `placementOffsetX` **[number][73]?** The horizontal offset, in pixels, of the popover. If
    `placementX` is set to `Popover.placements.LEFT`, a higher number will move the popover to the
    left. If `placementX` is set to `Popover.placements.RIGHT`, a higher number moves the popover to
    the right. If `placementX` is set to `Popover.placements.CENTER`, this value has no effect.
-   `placementOffsetY` **[number][73]?** The vertical offset, in pixels, of the popover. If
    `placementY` is set to `Popover.placements.TOP`, a higher number will move the popover upward.
    If `placementY` is set to `Popover.placements.BOTTOM`, a higher number moves the popover
    downard. If `placementY` is set to `Popover.placements.CENTER`, this value has no effect.
-   `fitInWindowMode` **(Popover.fitInWindowModes.FLIP | Popover.fitInWindowModes.NUDGE |
    Popover.fitInWindowModes.NONE)?** Dictates the behavior when the "normal" placement of the
    popover would be outside of the viewport. If `NONE`, this has no effect, and the popover may be
    placed off-screen. If `FLIP`, we'll switch the placement to the other side (for example, moving
    the popover from the left to the right). If `NUDGE`, the popover will be "nudged" just enough to
    fit on screen.
-   `onClose` **[function][71]?** A function that will be called when the popover closes.
-   `isOpen` **[boolean][69]** A boolean that dictates whether the popover is open.
-   `backgroundClassName` **[string][65]?** Extra class names for the background of the popover,
    separated by spaces.
-   `backgroundStyle` **[object][72]?** Extra styles for the background of the popover.

#### Popover.fitInWindowModes

An enum describing the fit-in-window mode. One of `Popover.fitInWindowModes.NONE`,
`Popover.fitInWindowModes.FLIP`, `Popover.fitInWindowModes.NUDGE`.

#### Popover.placements

An enum describing popover placements. One of `Popover.placements.TOP`, `Popover.placements.CENTER`,
`Popover.placements.BOTTOM`, `Popover.placements.LEFT`, `Popover.placements.RIGHT`.

### ProgressBar

#### ProgressBar

**Extends React.StatelessFunctionalComponent**

A progress bar.

##### Parameters

-   `props` **[ProgressBarProps][153]**

##### Examples

```javascript
import {UI} from '@airtable/blocks/ui';

function MyComponent() {
    return <ProgressBar progress={0.6} barColor="#ff9900" />;
}
```

#### ProgressBarProps

Type: [object][72]

##### Properties

-   `progress` **[number][73]** A number between 0 and 1. 0 is 0% complete, 0.5 is 50% complete, 1
    is 100% complete. If you include a number outside of the range, the value will be clamped to be
    inside of the range.
-   `barColor` **[string][65]?** A CSS color, such as `#ff9900`.
-   `backgroundColor` **[string][65]?** A CSS color, such as `#ff9900`.
-   `height` **[number][73]?** A height, in pixels.
-   `className` **[string][65]?** Extra `className`s to apply to the element, separated by spaces.
-   `style` **[object][72]?** Extra styles to apply to the progress bar.

### RecordCard

#### RecordCard

**Extends React.Component**

##### Parameters

-   `props` **[RecordCardProps][154]**

#### RecordCardProps

Type: [object][72]

##### Properties

-   `record` **[Record][84]** Record to display in the card.
-   `fields` **[Array][66]&lt;[Field][81]>?** Fields to display in the card. The primary field is
    always displayed.
-   `view` **[View][82]?** The view model to use for field order and record coloring.
-   `attachmentCoverField` **[Field][81]?** Attachment field to display as an image in the square
    preview for the card. If omitted or not an attachment field, it uses for the first attachment
    field in `fields`. If `fields` is not defined, it uses the first attachment field in the view.
-   `width` **[number][73]?** Width of the record card.
-   `height` **[number][73]?** Height of the record card.
-   `expandRecordOptions` **[object][72]?** Options object for expanding a record.
    -   `expandRecordOptions.records` **[Array][66]&lt;[Record][84]>?** List of all records, used
        for cycling through records in the same expanded record window.
-   `onClick` **[function][71]?** Click event handler for the record card. If undefined, uses
    default behavior to expand record. If null, no operation is performed.
-   `onMouseEnter` **[function][71]?** Mouse enter event handler for the record card.
-   `onMouseLeave` **[function][71]?** Mouse leave event handler for the record card.
-   `className` **[string][65]?** Additional class names to apply to the record card.
-   `style` **[object][72]?** Additional styles to apply to the record card.

### RecordCardList

#### RecordCardList

**Extends React.Component**

Scrollable list of record cards.

##### Parameters

-   `props` **[RecordCardListProps][155]**

##### Examples

```javascript
import {RecordCardList} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function Block() {
    const base = useBase();
    const [selectedRecord, setSelectedRecord] = useState(null);
    const table = base.getTableByName('Table 1');
    const view = table ? table.getViewByName('View 1') : null;
    const queryResult = table ? table.selectRecords() : null;
    const records = useRecords(queryResult);

    return (
        <RecordCardList
            records={records}
            view={view}
            onRecordClick={record => {
                setSelectedRecord(record);
            }}
        />
    );
}
```

#### RecordCardListProps

Type: [object][72]

##### Properties

-   `records` **[Array][66]&lt;[Record][84]>** Records to display in card list.
-   `onScroll` **[function][71]?** Scroll event handler for the list window.
-   `onRecordClick` **[function][71]?** Click event handler for an individual record card. If
    undefined, uses default behavior to expand record. If null, no operation is performed.
-   `onRecordMouseEnter` **[function][71]?** Mouse enter event handler for an individual record
    card.
-   `onRecordMouseLeave` **[function][71]?** Mouse leave event handler for an individual record
    card.
-   `fields` **[Array][66]&lt;[Field][81]>?** Fields to display in each record card. The primary
    field is always displayed.
-   `view` **[View][82]?** The view model to use for field order and record coloring.
-   `attachmentCoverField` **[Field][81]?** Attachment field to display as an image in the square
    preview for each record card. If omitted or not an attachment field, it uses for the first
    attachment field in `fields`. If `fields` is not defined, it uses the first attachment field in
    the view.
-   `className` **[string][65]?** Additional class names to apply to the record card list.
-   `style` **[object][72]?** Additional styles to apply to the record card list.

### Select

#### Select

**Extends React.Component**

Dropdown menu component. A wrapper around `<select>` that fits in with Airtable's user interface.

##### Parameters

-   `props` **[SelectProps][156]**

##### Examples

```javascript
import {Select} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function ColorPicker() {
    const [value, setValue] = useState(null);
    return (
        <label>
            <div style={{marginBottom: 8, fontWeight: 500}}>Color</div>
            <Select
                onChange={newValue => setValue(newValue)}
                value={value}
                options={[
                    {value: null, label: 'Pick a color...', disabled: true},
                    {value: 'red', label: 'red'},
                    {value: 'green', label: 'green'},
                    {value: 'blue', label: 'blue'},
                ]}
            />
        </label>
    );
}
```

#### SelectProps

Type: [object][72]

##### Properties

-   `value` **([string][65] \| [number][73] \| [boolean][69] | null)?** The value of the selected
    option.
-   `options` **[Array][66]&lt;[SelectOption][157]>** The list of select options.
-   `onChange` **[function][71]?** A function to be called when the selected option changes.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

#### SelectOption

Type: [object][72]

##### Properties

-   `value` **([string][65] \| [number][73] \| [boolean][69] | null)** The value for the select
    option.
-   `label` **React.Node** The label for the select option.
-   `disabled` **[boolean][69]?** If set to `true`, this option will not be selectable.

### SelectSynced

#### SelectSynced

**Extends React.Component**

Dropdown menu component synced with [GlobalConfig][3]. A wrapper around `<select>` that fits in with
Airtable's user interface.

##### Parameters

-   `props` **[SelectSyncedProps][158]**

##### Examples

```javascript
import {SelectSynced} from '@airtable/blocks/ui';
import React from 'react';

function ColorPickerSynced() {
    return (
        <label>
            <div style={{marginBottom: 8, fontWeight: 500}}>Color</div>
            <SelectSynced
                globalConfigKey="color"
                options={[
                    {value: null, label: 'Pick a color...', disabled: true},
                    {value: 'red', label: 'red'},
                    {value: 'green', label: 'green'},
                    {value: 'blue', label: 'blue'},
                ]}
            />
        </label>
    );
}
```

#### SelectSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The selected option will always reflect the value stored in `globalConfig`
    for this key. Selecting a new option will update `globalConfig`.
-   `options` **[Array][66]&lt;[SelectOption][157]>** The list of select options.
-   `onChange` **[function][71]?** A function to be called when the selected option changes. This
    should only be used for side effects.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### SelectButtons

#### SelectButtons

**Extends React.Component**

#### SelectButtonsProps

Type: [object][72]

##### Properties

-   `value` **([string][65] \| [number][73] \| [boolean][69] | null)?** The value of the selected
    option.
-   `options` **[Array][66]&lt;[SelectOption][157]>** The list of select options.
-   `onChange` **[function][71]?** A function to be called when the selected option changes.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### SelectButtonsSynced

#### SelectButtonsSynced

**Extends React.Component**

#### SelectButtonsSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The selected option will always reflect the value stored in `globalConfig`
    for this key. Selecting a new option will update `globalConfig`.
-   `options` **[Array][66]&lt;[SelectOption][157]>** The list of select options.
-   `onChange` **[function][71]?** A function to be called when the selected option changes.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the select.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the select.
-   `style` **[object][72]?** Additional styles to apply to the select.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### TablePicker

#### TablePicker

**Extends React.Component**

Dropdown menu component for selecting tables.

##### Parameters

-   `props` **[TablePickerProps][159]**

##### Examples

```javascript
import {TablePicker, useBase, useRecords} from '@airtable/blocks/ui';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const queryResult = table ? table.selectRecords() : null;
    const records = useRecords(queryResult);

    const summaryText = table
        ? `${table.name} has ${records.length} record(s).`
        : 'No table selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => setTable(newTable)}
                    shouldAllowPickingNone={true}
                />
            </label>
        </Fragment>
    );
}
```

#### TablePickerProps

Type: [object][72]

##### Properties

-   `table` **[Table][86]?** The selected table model.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    table.
-   `placeholder` **[string][65]?** The placeholder text when no table is selected.
-   `onChange` **[function][71]?** A function to be called when the selected table changes.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the picker.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the picker.
-   `style` **[object][72]?** Additional styles to apply to the picker.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### TablePickerSynced

#### TablePickerSynced

**Extends React.Component**

Dropdown menu component for selecting tables, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[TablePickerSyncedProps][160]**

##### Examples

```javascript
import {TablePickerSynced, useBase, useRecords, useWatchable} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const queryResult = table ? table.selectRecords() : null;
    const records = useRecords(queryResult);
    useWatchable(globalConfig, ['tableId']);

    const summaryText = table
        ? `${table.name} has ${records.length} record(s).`
        : 'No table selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
        </Fragment>
    );
}
```

#### TablePickerSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The selected table will always reflect the table id stored in `globalConfig`
    for this key. Selecting a new table will update `globalConfig`.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    table.
-   `placeholder` **[string][65]?** The placeholder text when no table is selected.
-   `onChange` **[function][71]?** A function to be called when the selected table changes. This
    should only be used for side effects.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the picker.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the picker.
-   `style` **[object][72]?** Additional styles to apply to the picker.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### Toggle

#### Toggle

**Extends React.Component**

A toggleable switch for controlling boolean values. Functionally analogous to a checkbox.

##### Parameters

-   `props` **[ToggleProps][161]**

##### Examples

```javascript
import {Toggle} from '@airtable/blocks/ui';
import React, {useState} from 'react';

function Block() {
    const [isEnabled, setIsEnabled] = useState(false);
    return <Toggle value={isEnabled} onChange={setIsEnabled} label={isEnabled ? 'On' : 'Off'} />;
}
```

#### ToggleProps

Type: [object][72]

##### Properties

-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the switch.
-   `id` **[string][65]?** The ID of the switch element.
-   `label` **React.Node?** The label node for the switch.
-   `onChange` **[function][71]?** A function to be called when the switch is toggled.
-   `tabIndex` **([number][73] \| [string][65])?** Indicates if the switch can be focused and
    if/where it participates in sequential keyboard navigation.
-   `theme` **(Toggle.themes.GREEN | Toggle.themes.BLUE | Toggle.themes.RED | Toggle.themes.YELLOW |
    Toggle.themes.GRAY)?** The color theme for the switch.
-   `value` **[boolean][69]** If set to `true`, the switch will be toggled on.
-   `className` **[string][65]?** Additional class names to apply to the switch.
-   `style` **[object][72]?** Additional styles to apply to the switch.
-   `aria-label` **[string][65]?** The label for the switch. Use this if the switch lacks a visible
    text label.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### ToggleSynced

#### ToggleSynced

**Extends React.Component**

A toggleable switch for controlling boolean values, synced with [GlobalConfig][3]. Functionally
analogous to a checkbox.

##### Parameters

-   `props` **[ToggleSyncedProps][162]**

##### Examples

```javascript
import {ToggleSynced, useWatchable} from '@airtable/blocks/ui';
import {globalConfig} from '@airtable/blocks';
import React from 'react';

function Block() {
    useWatchable(globalConfig, ['isEnabled']);
    return (
        <Toggle globalConfigKey="isEnabled" label={globalConfig.get('isEnabled') ? 'On' : 'Off'} />
    );
}
```

#### ToggleSyncedProps

Type: [object][72]

##### Properties

-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the switch.
-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The switch option will always reflect the boolean value stored in
    `globalConfig` for this key. Toggling the switch will update `globalConfig`.
-   `id` **[string][65]?** The ID of the switch element.
-   `label` **React.Node?** The label node for the switch.
-   `onChange` **[function][71]?** A function to be called when the switch is toggled. This should
    only be used for side effects.
-   `tabIndex` **([number][73] \| [string][65])?** Indicates if the switch can be focused and
    if/where it participates in sequential keyboard navigation.
-   `theme` **(Toggle.themes.GREEN | Toggle.themes.BLUE | Toggle.themes.RED | Toggle.themes.YELLOW |
    Toggle.themes.GRAY)?** The color theme for the switch.
-   `className` **[string][65]?** Additional class names to apply to the switch.
-   `style` **[object][72]?** Additional styles to apply to the switch.
-   `aria-label` **[string][65]?** The label for the switch. Use this if the switch lacks a visible
    text label.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### Tooltip

#### Tooltip

**Extends React.Component**

A component that shows a tooltip. Wraps its children.

##### Parameters

-   `props` **[TooltipProps][163]**

##### Examples

```javascript
import {UI} from '@airtable/blocks';

function MyComponent() {
    return (
        <UI.Tooltip
            content="Clicking this button will be a lot of fun!"
            placementX={UI.Tooltip.placements.CENTER}
            placementY={UI.Tooltip.placements.TOP}
        >
            <UI.Button onClick={() => alert('Clicked!')}>Click here!</UI.Button>
        </UI.Tooltip>
    );
}
```

#### TooltipProps

Type: [object][72]

##### Properties

-   `children` **React\$Element&lt;any>** Child components to render.
-   `content` **([string][65] \| [function][71])** A string representing the contents.
    Alternatively, you can include a function that returns a React node to place into the tooltip,
    which is useful for things like italicization in the tooltip.
-   `placementX` **(UI.Tooltip.placements.LEFT | UI.Tooltip.placements.CENTER |
    UI.Tooltip.placements.RIGHT)?** The horizontal placement of the tooltip.
-   `placementY` **(UI.Tooltip.placements.TOP | UI.Tooltip.placements.CENTER |
    UI.Tooltip.placements.BOTTOM)?** The vertical placement of the tooltip.
-   `placementOffsetX` **[number][73]?** The horizontal offset, in pixels, of the tooltip. If
    `placementX` is set to `UI.Tooltip.placements.LEFT`, a higher number will move the tooltip to
    the left. If `placementX` is set to `UI.Tooltip.placements.RIGHT`, a higher number moves the
    tooltip to the right. If `placementX` is set to `UI.Tooltip.placements.CENTER`, this value has
    no effect.
-   `placementOffsetY` **[number][73]?** The vertical offset, in pixels, of the tooltip. If
    `placementY` is set to `UI.Tooltip.placements.TOP`, a higher number will move the tooltip
    upward. If `placementY` is set to `UI.Tooltip.placements.BOTTOM`, a higher number moves the
    tooltip downard. If `placementY` is set to `UI.Tooltip.placements.CENTER`, this value has no
    effect.
-   `fitInWindowMode` **(UI.Tooltip.fitInWindowModes.FLIP | UI.Tooltip.fitInWindowModes.NUDGE |
    UI.Tooltip.fitInWindowModes.NONE)?** Dictates the behavior when the "normal" placement of the
    tooltip would be outside of the viewport. If `NONE`, this has no effect, and the tooltip may be
    placed off-screen. If `FLIP`, we'll switch the placement to the other side (for example, moving
    the tooltip from the left to the right). If `NUDGE`, the tooltip will be "nudged" just enough to
    fit on screen.
-   `shouldHideTooltipOnClick` **[boolean][69]?** Should the tooltip be hidden when clicked?
-   `disabled` **[boolean][69]?** If set to `true`, this tooltip will not be shown. Useful when
    trying to disable the tooltip dynamically.
-   `className` **[string][65]?** Additional class names to attach to the tooltip, separated by
    spaces.
-   `style` **[object][72]?** Additional styles names to attach to the tooltip.

### ViewPicker

#### ViewPicker

**Extends React.Component**

Dropdown menu component for selecting views.

##### Parameters

-   `props` **[ViewPickerProps][164]**

##### Examples

```javascript
import {TablePicker, ViewPicker, useBase, useRecords} from '@airtable/blocks/ui';
import {viewTypes} from '@airtable/blocks/models';
import React, {Fragment, useState} from 'react';

function Block() {
    useBase();
    const [table, setTable] = useState(null);
    const [view, setView] = useState(null);
    const queryResult = view ? view.selectRecords() : null;
    const records = useRecords(queryResult);

    const summaryText = view
        ? `${view.name} has ${records.length} record(s).`
        : 'No view selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePicker
                    table={table}
                    onChange={newTable => {
                        setTable(newTable);
                        setView(null);
                    }}
                    shouldAllowPickingNone={true}
                />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>View</div>
                    <ViewPicker
                        table={table}
                        view={view}
                        onChange={newView => setView(newView)}
                        allowedTypes={[viewTypes.GRID]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### ViewPickerProps

Type: [object][72]

##### Properties

-   `view` **[View][82]?** The selected view model.
-   `table` **[Table][86]?** The parent table model to select views from. If `null` or `undefined`,
    the picker won't render.
-   `allowedTypes` **[Array][66]&lt;ViewType>?** An array indicating which view types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    view.
-   `placeholder` **[string][65]?** The placeholder text when no view is selected.
-   `onChange` **[function][71]?** A function to be called when the selected view changes.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the picker.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the picker.
-   `style` **[object][72]?** Additional styles to apply to the picker.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### ViewPickerSynced

#### ViewPickerSynced

**Extends React.Component**

Dropdown menu component for selecting views, synced with [GlobalConfig][3].

##### Parameters

-   `props` **[ViewPickerSyncedProps][165]**

##### Examples

```javascript
import {
    TablePickerSynced,
    ViewPickerSynced,
    useBase,
    useRecords,
    useWatchable,
} from '@airtable/blocks/ui';
import {viewTypes} from '@airtable/blocks/models';
import {globalConfig} from '@airtable/blocks';
import React, {Fragment} from 'react';

function Block() {
    const base = useBase();
    const tableId = globalConfig.get('tableId');
    const table = base.getTableByIdIfExists(tableId);
    const viewId = globalConfig.get('viewId');
    const view = table.getViewByIdIfExists(viewId);
    const queryResult = view ? view.selectRecords() : null;
    const records = useRecords(queryResult);
    useWatchable(globalConfig, ['tableId', 'viewId']);

    const summaryText = view
        ? `${view.name} has ${records.length} record(s).`
        : 'No view selected.';
    return (
        <Fragment>
            <p style={{marginBottom: 16}}>{summaryText}</p>
            <label style={{display: 'block', marginBottom: 16}}>
                <div style={{marginBottom: 8, fontWeight: 500}}>Table</div>
                <TablePickerSynced globalConfigKey="tableId" shouldAllowPickingNone={true} />
            </label>
            {table && (
                <label>
                    <div style={{marginBottom: 8, fontWeight: 500}}>View</div>
                    <ViewPickerSynced
                        table={table}
                        globalConfigKey="viewId"
                        allowedTypes={[viewTypes.GRID]}
                        shouldAllowPickingNone={true}
                    />
                </label>
            )}
        </Fragment>
    );
}
```

#### ViewPickerSyncedProps

Type: [object][72]

##### Properties

-   `globalConfigKey` **[GlobalConfigKey][138]** A string key or array key path in
    [GlobalConfig][3]. The selected view will always reflect the view id stored in `globalConfig`
    for this key. Selecting a new view will update `globalConfig`.
-   `table` **[Table][86]?** The parent table model to select views from. If `null` or `undefined`,
    the picker won't render.
-   `allowedTypes` **[Array][66]&lt;ViewType>?** An array indicating which view types can be
    selected.
-   `shouldAllowPickingNone` **[boolean][69]?** If set to `true`, the user can unset the selected
    view.
-   `placeholder` **[string][65]?** The placeholder text when no view is selected.
-   `onChange` **[function][71]?** A function to be called when the selected view changes. This
    should only be used for side effects.
-   `autoFocus` **[string][65]?** The `autoFocus` attribute.
-   `disabled` **[boolean][69]?** If set to `true`, the user cannot interact with the picker.
-   `id` **[string][65]?** The `id` attribute.
-   `name` **[string][65]?** The `name` attribute.
-   `tabIndex` **([number][73] \| [string][65])?** The `tabindex` attribute.
-   `className` **[string][65]?** Additional class names to apply to the picker.
-   `style` **[object][72]?** Additional styles to apply to the picker.
-   `aria-label` **[string][65]?** The `aria-label` attribute. Use this if the select is not
    referenced by a label element.
-   `aria-labelledby` **[string][65]?** A space separated list of label element IDs.
-   `aria-describedby` **[string][65]?** A space separated list of description element IDs.

### ViewportConstraint

#### ViewportConstraint

**Extends React.Component**

-   **See: sdk.viewport**

ViewportConstraint - when mounted, applies constraints to the viewport. Like [addMinSize][166], will
fullscreen the block if necessary and possible when `minSize` is updated.

##### Examples

```javascript
import {ViewportConstraint} from '@airtable/blocks/ui';
<ViewportConstraint minSize={{width: 400}} />;
```

```javascript
import {ViewportConstraint} from '@airtable/blocks/ui';
<ViewportConstraint maxFullScreenSize={{width: 600, height: 400}}>
    <div>I need a max fullscreen size!</div>
</ViewportConstraint>;
```

#### ViewportConstraintProps

Type: {minSize: [ViewportSizeConstraintProp][167]?, maxFullscreenSize:
[ViewportSizeConstraintProp][167]?, children: React.Node?}

##### Properties

-   `minSize` **[ViewportSizeConstraintProp][167]?**
-   `maxFullscreenSize` **[ViewportSizeConstraintProp][167]?**
-   `children` **React.Node?**

#### ViewportSizeConstraintProp

Type: {width: ([number][73] | null)?, height: ([number][73] | null)?}

##### Properties

-   `width` **([number][73] | null)?**
-   `height` **([number][73] | null)?**

[1]: #airtableblocks
[2]: #sdk
[3]: #globalconfig
[4]: #settingsbutton
[5]: #viewport
[6]: #airtableblocksmodels
[7]: #fieldtypes
[8]: #viewtypes
[9]: #recordcoloring
[10]: #abstractmodel
[11]: #abstractmodelwithasyncdata
[12]: #aggregator
[13]: #base
[14]: #session
[15]: #cursor
[16]: #field
[17]: #recordqueryresult
[18]: #record
[19]: #table
[20]: #view
[21]: #viewmetadataqueryresult
[22]: #watchable
[23]: #airtableblocksui
[24]: #initializeblock
[25]: #css--external-scripts
[26]: #color-utilities
[27]: #react-hooks-for-working-with-airtable-data
[28]: #expandrecord
[29]: #expandrecordlist
[30]: #expandrecordpickerasync
[31]: #button
[32]: #cellrenderer
[33]: #choicetoken
[34]: #collaboratortoken
[35]: #colorpalette
[36]: #colorpalettesynced
[37]: #confirmationdialog
[38]: #dialog
[39]: #fieldpicker
[40]: #fieldpickersynced
[41]: #icon
[42]: #input
[43]: #inputsynced
[44]: #link
[45]: #loader
[46]: #popover
[47]: #progressbar
[48]: #recordcard
[49]: #recordcardlist
[50]: #select
[51]: #selectsynced
[52]: #selectbuttons
[53]: #selectbuttonssynced
[54]: #tablepicker
[55]: #tablepickersynced
[56]: #toggle
[57]: #togglesynced
[58]: #tooltip
[59]: #viewpicker
[60]: #viewpickersynced
[61]: #viewportconstraint
[62]: #usebase
[63]: #usesession
[64]: #setAsync
[65]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String
[66]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array
[67]: #globalconfigvalue
[68]: #setPathsAsync
[69]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean
[70]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise
[71]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function
[72]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object
[73]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number
[74]: #usesettingsbutton
[75]: #addmaxfullscreensize
[76]: #minsize
[77]: https://www.iso.org/iso-8601-date-and-time-format.html
[78]: #fieldtypesdate
[79]: #fieldtypesdate_time
[80]: https://airtable.com/universe
[81]: #field
[82]: #view
[83]: #recordcoloringmodes
[84]: #record
[85]: #getcollaboratorbyidifexists
[86]: #table
[87]: #gettablebyidifexists
[88]: #gettablebynameifexists
[89]: #aggregator
[90]: #tableorviewqueryresult
[91]: #linkedrecordsqueryresult
[92]: https://support.airtable.com/hc/en-us/articles/206452848-Linked-record-fields
[93]: #userecords
[94]: #userecordids
[95]: #userecordbyid
[96]: #useloadable
[97]: #color
[98]: #color
[99]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date
[100]: #linkedrecordsqueryresult
[101]: #createrecordasync
[102]: #createrecordsasync
[103]: #deleteRecordAsync
[104]: #deleteRecordsAsync
[105]: #updateRecordAsync
[106]: #updateRecordsAsync
[107]: /packages/sdk/docs/guide_writes.md
[108]: #getfieldbyidifexists
[109]: #getfieldbynameifexists
[110]: #getviewbyidifexists
[111]: #getviewbynameifexists
[112]: #tableorviewqueryresult
[113]: #viewmetadataqueryresult
[114]: #useviewmetadata
[115]: https://developer.mozilla.org/docs/Web/API/HTMLStyleElement
[116]: https://developer.mozilla.org/docs/Web/API/HTMLLinkElement
[117]: https://developer.mozilla.org/docs/Web/API/HTMLScriptElement
[118]: #colors
[119]: #rgb
[120]: #rgb
[121]: https://reactjs.org/docs/hooks-intro.html
[122]: #withhooks
[123]: #usewatchable
[124]: #base
[125]: #globalconfig
[126]: #session
[127]: #viewport
[128]: #useviewport
[129]: #watchable
[130]: https://reactjs.org/docs/react-api.html#reactsuspense
[131]: #cursor
[132]: https://reactjs.org/docs/forwarding-refs.html
[133]: #buttonprops
[134]: #cellrendererprops
[135]: #choicetokenprops
[136]: #collaboratortokenprops
[137]: #colorpaletteprops
[138]: #globalconfigkey
[139]: #confirmationdialogprops
[140]: #dialogprops
[141]: #dialogclosebuttonprops
[142]: #fieldpickerprops
[143]: #fieldpickersyncedprops
[144]: #iconprops
[145]: /packages/sdk/docs/icons.md
[146]: #fieldiconprops
[147]: #inputprops
[148]: #inputsyncedprops
[149]: https://www.owasp.org/index.php/Reverse_Tabnabbing
[150]: #linkprops
[151]: #loaderprops
[152]: #popoverprops
[153]: #progressbarprops
[154]: #recordcardprops
[155]: #recordcardlistprops
[156]: #selectprops
[157]: #selectoption
[158]: #selectsyncedprops
[159]: #tablepickerprops
[160]: #tablepickersyncedprops
[161]: #toggleprops
[162]: #togglesyncedprops
[163]: #tooltipprops
[164]: #viewpickerprops
[165]: #viewpickersyncedprops
[166]: #addminsize
[167]: #viewportsizeconstraintprop
